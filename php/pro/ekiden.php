<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \React\Async;
use \React\Promise\PromiseInterface;

class ekiden extends \ccxt\async\ekiden {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOHLCV' => true,
                'watchOrders' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://api.ekiden.fi/ws',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => 'wss://api.staging.ekiden.fi/ws',
                    ),
                ),
            ),
            'streaming' => array(
                'keepAlive' => 20000,
            ),
            'options' => array(
                'OHLCVLimit' => 1000,
                'ordersLimit' => 1000,
                'ordersPollInterval' => 2000,
            ),
        ));
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            // subscribe to public trades $channel and aggregate candles client-side
            $channel = 'trades/' . $market['id'];
            $url = $this->urls['api']['ws']['public'];
            $request = array(
                'method' => 'subscribe',
                'channel' => $channel,
            );
            // ensure cache exists for this symbol/timeframe
            if (!(is_array($this->ohlcvs) && array_key_exists($symbol, $this->ohlcvs))) {
                $this->ohlcvs[$symbol] = array();
            }
            if (!(is_array($this->ohlcvs[$symbol]) && array_key_exists($timeframe, $this->ohlcvs[$symbol]))) {
                $ohlcvLimit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $this->ohlcvs[$symbol][$timeframe] = new ArrayCacheByTimestamp ($ohlcvLimit);
            }
            $messageHash = 'candles:' . $timeframe . ':' . $symbol;
            $ohlcv = Async\await($this->watch($url, $messageHash, $this->extend($request, $params), $messageHash));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            // HTTP polling-based watcher $since Ekiden WS has no $orders channel yet
            Async\await($this->load_markets());
            $this->check_required_credentials(false);
            $market = null;
            $messageHash = 'order';
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash = $messageHash . ':' . $symbol;
            }
            $url = $this->urls['api']['ws']['public'];
            $client = $this->client($url);
            if ($this->safe_value($client->subscriptions, $messageHash) === null) {
                $client->subscriptions[$messageHash] = true;
                $this->spawn(array($this, 'watch_orders_loop'), $client, $messageHash, $market, $params);
            }
            $future = $client->future ($messageHash);
            $orders = Async\await($future);
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function watch_orders_loop(Client $client, string $messageHash, mixed $market = null, $params = array ()) {
        return Async\async(function () use ($client, $messageHash, $market, $params) {
            $pollMs = $this->safe_integer($this->options, 'ordersPollInterval', 2000);
            try {
                $request = array();
                if ($market !== null) {
                    $request['market_addr'] = $market['id'];
                }
                // fetch the latest user $orders (both open/closed)
                $response = Async\await($this->v1PrivateGetUserOrders ($this->extend($request, $params)));
                if ($this->orders === null) {
                    $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                    $this->orders = new ArrayCacheBySymbolById ($limit);
                }
                $stored = $this->orders;
                $orders = $this->parse_orders($response, $market);
                $symbols = array();
                for ($i = 0; $i < count($orders); $i++) {
                    $order = $orders[$i];
                    $stored->append ($order);
                    $sym = $this->safe_string($order, 'symbol');
                    if ($sym !== null) {
                        $symbols[$sym] = true;
                    }
                }
                // resolve both generic and per-symbol streams
                $client->resolve ($stored, 'order');
                $keys = is_array($symbols) ? array_keys($symbols) : array();
                for ($i = 0; $i < count($keys); $i++) {
                    $sym = $keys[$i];
                    $innerHash = 'order' . ':' . $sym;
                    $client->resolve ($stored, $innerHash);
                }
            } catch (Exception $e) {
                // eslint-disable-next-line no-unused-vars
                $_ = $e; // no-op to satisfy transpilers
            }
            $this->delay($pollMs, array($this, 'watch_orders_loop'), $client, $messageHash, $market, $params);
        }) ();
    }

    public function handle_message(Client $client, $message) {
        // Ekiden WS $message format (server-side):
        // array( type => 'event' | 'subscribed' | 'unsubscribed' | 'pong' | 'error', $channel? => string, $data? => array( type => 'trades' | 'orderbook_snapshot' | 'orderbook_delta', ... ) )
        $topType = $this->safe_string($message, 'type');
        if ($topType === 'event') {
            $channel = $this->safe_string($message, 'channel');
            $data = $this->safe_dict($message, 'data', array());
            $eventType = $this->safe_string($data, 'type');
            if (($channel !== null) && (mb_strpos($channel, 'trades/') === 0) && ($eventType === 'trades')) {
                $this->handle_trades_for_ohlcv($client, $message);
            }
            // ignore orderbook events here (no watchOrderBook implemented yet)
        }
        if ($topType === 'error') {
            $err = $this->id . ' ' . $this->json($message);
            $client->reject ($err);
        }
        // subscribed / unsubscribed / pong can be ignored
    }

    public function handle_trades_for_ohlcv(Client $client, $message) {
        $data = $this->safe_dict($message, 'data', array());
        $marketAddr = $this->safe_string($data, 'market_addr');
        $market = $this->safe_market($marketAddr);
        $symbol = $market['symbol'];
        $baseDecimals = $this->safe_integer($market['info'] || array(), 'base_decimals');
        $quoteDecimals = $this->safe_integer($market['info'] || array(), 'quote_decimals');
        $trades = $this->safe_list($data, 'trades', array());
        if (!(is_array($this->ohlcvs) && array_key_exists($symbol, $this->ohlcvs))) {
            // nothing to deliver if there are no OHLCV subscriptions for this $symbol
            return;
        }
        $timeframes = is_array($this->ohlcvs[$symbol]) ? array_keys($this->ohlcvs[$symbol]) : array();
        if (strlen($timeframes) === 0) {
            return;
        }
        for ($i = 0; $i < count($trades); $i++) {
            $tr = $this->safe_dict($trades, $i);
            $ts = $this->safe_integer($tr, 'timestamp');
            $timestamp = ($ts !== null) ? ($ts * 1000) : null;
            $priceInt = $this->safe_integer($tr, 'price');
            $sizeInt = $this->safe_integer($tr, 'size');
            $price = ($quoteDecimals !== null && $priceInt !== null) ? ($priceInt / pow(10, $quoteDecimals)) : null;
            $amount = ($baseDecimals !== null && $sizeInt !== null) ? ($sizeInt / pow(10, $baseDecimals)) : null;
            if (($timestamp === null) || ($price === null) || ($amount === null)) {
                continue;
            }
            for ($j = 0; $j < count($timeframes); $j++) {
                $timeframe = $timeframes[$j];
                $this->append_ohlcv_from_trade($symbol, $timeframe, $timestamp, $price, $amount);
            }
        }
        for ($j = 0; $j < count($timeframes); $j++) {
            $timeframe = $timeframes[$j];
            $messageHash = 'candles:' . $timeframe . ':' . $symbol;
            $cache = $this->ohlcvs[$symbol][$timeframe];
            $client->resolve ($cache, $messageHash);
        }
    }

    public function append_ohlcv_from_trade(string $symbol, string $timeframe, float $timestamp, float $price, float $amount) {
        if (!(is_array($this->ohlcvs) && array_key_exists($symbol, $this->ohlcvs))) {
            $this->ohlcvs[$symbol] = array();
        }
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $duration = $this->parse_timeframe($timeframe) * 1000;
        $start = $this->parse_to_int((int) floor($timestamp / $duration) * $duration);
        $existing = $stored->hashmap[$start];
        if ($existing !== null) {
            $open = $existing[1];
            $high = max ($existing[2], $price);
            $low = min ($existing[3], $price);
            $close = $price;
            $volume = $this->sum($existing[5], $amount);
            $stored->append (array( $start, $open, $high, $low, $close, $volume ));
        } else {
            $stored->append (array( $start, $price, $price, $price, $price, $amount ));
        }
    }
}
