// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

//  ---------------------------------------------------------------------------
import Exchange from './abstract/ekiden.js';
import { DECIMAL_PLACES } from './base/functions/number.js';
import { ArgumentsRequired, OrderNotFound, NotSupported } from './base/errors.js';
import { ed25519 } from './static_dependencies/noble-curves/ed25519.js';
//  ---------------------------------------------------------------------------
/**
 * @class ekiden
 * @augments Exchange
 */
export default class ekiden extends Exchange {
    // --- Intent signing helpers (mirrors ts-sdk buildOrderPayload) ---
    intentSeed() {
        // Same SEED used in ts-sdk composeHexPayload
        return new Uint8Array([226, 172, 78, 86, 136, 217, 100, 39, 10, 216, 118, 215, 96, 194, 235, 178, 213, 79, 178, 109, 147, 81, 44, 121, 0, 73, 182, 88, 55, 48, 208, 111]);
    }
    encodeUleb128(value) {
        const out = [];
        let v = value;
        while (v >= 0x80) {
            const low7 = v % 128;
            out.push(low7 + 0x80);
            v = Math.floor(v / 0x80);
        }
        out.push(v);
        return new Uint8Array(out);
    }
    encodeU64LE(value) {
        const x = BigInt(value);
        const out = new Uint8Array(8);
        for (let i = 0; i < 8; i++) {
            const divisor = 256n ** BigInt(i);
            out[i] = Number((x / divisor) % 256n);
        }
        return out;
    }
    concatBytes(arrays) {
        const total = arrays.reduce((acc, a) => acc + a.length, 0);
        const out = new Uint8Array(total);
        let offset = 0;
        for (let i = 0; i < arrays.length; i++) {
            out.set(arrays[i], offset);
            offset += arrays[i].length;
        }
        return out;
    }
    serializeString(value) {
        const enc = new TextEncoder();
        const bytes = enc.encode(value);
        return this.concatBytes([this.encodeUleb128(bytes.length), bytes]);
    }
    serializeActionPayload(payload) {
        // Mirrors ts-sdk/src/utils/buildOrderPayload.ts
        const chunks = [this.serializeString(this.safeString(payload, 'type'))];
        if (payload['type'] === 'leverage_assign') {
            chunks.push(this.encodeU64LE(BigInt(this.safeInteger(payload, 'leverage'))));
            chunks.push(this.serializeString(this.safeString(payload, 'market_addr')));
        }
        else if (payload['type'] === 'order_cancel') {
            const cancels = payload['cancels'] || [];
            chunks.push(this.encodeUleb128(cancels.length));
            for (let i = 0; i < cancels.length; i++) {
                chunks.push(this.serializeString(this.safeString(cancels[i], 'sid')));
            }
        }
        else if (payload['type'] === 'order_create') {
            const orders = payload['orders'] || [];
            chunks.push(this.encodeUleb128(orders.length));
            for (let i = 0; i < orders.length; i++) {
                const o = orders[i];
                chunks.push(this.serializeString(this.safeString(o, 'side')));
                chunks.push(this.encodeU64LE(BigInt(this.safeInteger(o, 'size'))));
                chunks.push(this.encodeU64LE(BigInt(this.safeInteger(o, 'price'))));
                chunks.push(this.encodeU64LE(BigInt(this.safeInteger(o, 'leverage'))));
                chunks.push(this.serializeString(this.safeString(o, 'type')));
                chunks.push(this.serializeString(this.safeString(o, 'market_addr')));
            }
        }
        else {
            throw new NotSupported(this.id + ' unsupported payload type: ' + payload['type']);
        }
        return this.concatBytes(chunks);
    }
    buildMessage(payloadBytes, nonce) {
        return this.concatBytes([this.intentSeed(), payloadBytes, this.encodeU64LE(BigInt(nonce))]);
    }
    bytesToHex(arr) {
        const hex = new Array(arr.length);
        for (let i = 0; i < arr.length; i++) {
            hex[i] = arr[i].toString(16).padStart(2, '0');
        }
        return '0x' + hex.join('');
    }
    signMessage(message) {
        const privateKeyHex = this.privateKey;
        const value = privateKeyHex.startsWith('0x') ? privateKeyHex.slice(2) : privateKeyHex;
        const pk = new Uint8Array(value.length / 2);
        for (let i = 0; i < pk.length; i++) {
            pk[i] = parseInt(value.slice(i * 2, i * 2 + 2), 16);
        }
        const sig = ed25519.sign(message, pk);
        return this.bytesToHex(sig);
    }
    buildSignedIntent(payload, nonce) {
        const payloadBytes = this.serializeActionPayload(payload);
        const message = this.buildMessage(payloadBytes, nonce);
        const signature = this.signMessage(message);
        return { 'payload': payload, 'nonce': nonce, 'signature': signature };
    }
    isValidSignedIntentParams(params, expectedType = undefined) {
        const payload = this.safeValue(params, 'payload');
        const payloadType = this.safeString(payload, 'type');
        const sig = this.safeString(params, 'signature');
        const hasNonce = ('nonce' in params);
        const hasType = (payloadType !== undefined);
        const typeOk = (expectedType === undefined) ? true : (payloadType === expectedType);
        const sigOk = (sig !== undefined) && (sig.length > 2);
        return !!(payload && hasType && typeOk && sigOk && hasNonce);
    }
    scaleOrderFields(market, side, amount, price, type, leverage) {
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const sizeInt = (baseDecimals !== undefined && amount !== undefined) ? this.parseToInt(amount * Math.pow(10, baseDecimals)) : undefined;
        const priceInt = (quoteDecimals !== undefined && price !== undefined) ? this.parseToInt(price * Math.pow(10, quoteDecimals)) : 0;
        return {
            'market_addr': market['id'],
            'side': side,
            'size': sizeInt,
            'price': priceInt,
            'type': type,
            'leverage': leverage,
        };
    }
    parseCancelOrderResult(response, requestedId, market = undefined) {
        // Attempt to locate the canceled sid in outputs; fall back to requestedId
        let id = requestedId;
        const output = this.safeValue(response, 'output');
        const outputType = this.safeString(output, 'type');
        if (output && outputType === 'order_cancel') {
            const outputs = this.safeValue(output, 'outputs', []);
            if ((outputs !== undefined) && (outputs.length > 0)) {
                const first = outputs[0];
                const sid = this.safeString(first, 'sid');
                if (sid !== undefined) {
                    id = sid;
                }
            }
        }
        const ts = this.safeInteger(response, 'timestamp');
        const timestamp = (ts !== undefined) ? (ts * 1000) : undefined;
        return this.safeOrder({
            'id': id,
            'clientOrderId': undefined,
            'timestamp': timestamp,
            'datetime': (timestamp !== undefined) ? this.iso8601(timestamp) : undefined,
            'lastTradeTimestamp': undefined,
            'status': 'canceled',
            'symbol': market ? market['symbol'] : undefined,
            'type': undefined,
            'timeInForce': undefined,
            'postOnly': undefined,
            'side': undefined,
            'price': undefined,
            'stopPrice': undefined,
            'triggerPrice': undefined,
            'takeProfitPrice': undefined,
            'stopLossPrice': undefined,
            'cost': undefined,
            'amount': undefined,
            'filled': undefined,
            'remaining': undefined,
            'average': undefined,
            'fee': undefined,
            'trades': [],
            'reduceOnly': undefined,
            'info': response,
        }, market);
    }
    parseCreateOrderResult(response, payload, market, amount, price, side, type) {
        // Extract order sid from response.output or response.sid
        let id = undefined;
        const output = this.safeValue(response, 'output');
        const outputType = this.safeString(output, 'type');
        if (output && outputType === 'order_create') {
            const outputs = this.safeValue(output, 'outputs', []);
            if ((outputs !== undefined) && (outputs.length > 0)) {
                id = this.safeString(outputs[0], 'sid');
            }
        }
        if (id === undefined) {
            id = this.safeString(response, 'sid');
        }
        const ts = this.safeInteger(response, 'timestamp');
        const timestamp = (ts !== undefined) ? (ts * 1000) : undefined;
        // Best-effort mapped order
        return this.safeOrder({
            'id': id,
            'clientOrderId': undefined,
            'timestamp': timestamp,
            'datetime': (timestamp !== undefined) ? this.iso8601(timestamp) : undefined,
            'lastTradeTimestamp': undefined,
            'status': 'open',
            'symbol': market ? market['symbol'] : undefined,
            'type': type,
            'timeInForce': undefined,
            'postOnly': undefined,
            'side': side,
            'price': price,
            'stopPrice': undefined,
            'triggerPrice': undefined,
            'takeProfitPrice': undefined,
            'stopLossPrice': undefined,
            'cost': undefined,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'average': undefined,
            'fee': undefined,
            'trades': [],
            'reduceOnly': undefined,
            'info': response,
        }, market);
    }
    describe() {
        return this.deepExtend(super.describe(), {
            'id': 'ekiden',
            'name': 'Ekiden',
            'countries': [],
            'rateLimit': 50,
            'version': 'v1',
            'certified': false,
            'pro': false,
            'dex': true,
            'has': {
                'CORS': undefined,
                'spot': false,
                'margin': false,
                'swap': true,
                'future': false,
                'option': false,
                'cancelAllOrders': false,
                'cancelOrder': true,
                'createOrder': true,
                'fetchBalance': true,
                'fetchClosedOrders': true,
                'fetchMarkets': true,
                'fetchMyTrades': false,
                'fetchOHLCV': true,
                'fetchOpenOrders': true,
                'fetchOrder': true,
                'fetchOrderBook': true,
                'fetchPositions': false,
                'fetchTicker': true,
                'fetchTickers': false,
                'fetchTrades': true,
                'sandbox': true,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
            },
            'urls': {
                'logo': 'https://raw.githubusercontent.com/ekidenfi/ekiden-docs/refs/heads/main/logo/dark.svg',
                'api': {
                    'public': 'https://api.ekiden.fi',
                    'private': 'https://api.ekiden.fi',
                },
                'www': 'https://ekiden.fi',
                'doc': [
                    'https://docs.ekiden.fi',
                ],
            },
            'precisionMode': DECIMAL_PLACES,
            'requiredCredentials': {
                'apiKey': false,
                'secret': false,
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'market/candles': 1,
                            'market/candles/stats/{market_addr}': 1,
                            'market/market_info': 1,
                            'market/fills': 1,
                            'market/orders': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'user/orders': 1,
                        },
                        'post': {
                            'user/intent': 1,
                            'user/intent/commit': 1,
                        },
                    },
                },
            },
            'options': {
                'sandboxMode': false,
            },
            'commonCurrencies': {},
        });
    }
    sign(path, api = [], method = 'GET', params = {}, headers = undefined, body = undefined) {
        const version = api[0];
        const scope = api[1]; // 'public' | 'private'
        const fullPath = '/api/' + version + '/' + this.implodeParams(path, params);
        let url = this.urls['api'][scope] + fullPath;
        params = this.omit(params, this.extractParams(path));
        if (method === 'GET') {
            const query = this.urlencode(params);
            if (query.length) {
                url += '?' + query;
            }
        }
        else {
            if (params) {
                body = this.json(params);
            }
        }
        headers = { 'Content-Type': 'application/json' };
        if (scope === 'private' && this.apiKey) {
            headers['Authorization'] = 'Bearer ' + this.apiKey;
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
    async fetchMarkets(params = {}) {
        const response = await this.v1PublicGetMarketMarketInfo(params);
        // response: array of MarketResponse
        const result = [];
        for (let i = 0; i < response.length; i++) {
            const market = response[i];
            const id = this.safeString(market, 'addr');
            const symbol = this.safeString(market, 'symbol');
            const baseId = this.safeString(market, 'base_addr');
            const quoteId = this.safeString(market, 'quote_addr');
            const baseDecimals = this.safeInteger(market, 'base_decimals');
            const quoteDecimals = this.safeInteger(market, 'quote_decimals');
            const linear = true;
            const type = 'swap';
            const settle = undefined;
            const settleId = undefined;
            const active = true;
            const precision = { 'amount': baseDecimals, 'price': quoteDecimals };
            result.push({
                'id': id,
                'symbol': symbol,
                'base': baseId,
                'quote': quoteId,
                'baseId': baseId,
                'quoteId': quoteId,
                'type': type,
                'spot': false,
                'margin': false,
                'swap': true,
                'future': false,
                'option': false,
                'contract': true,
                'linear': linear,
                'inverse': !linear,
                'settle': settle,
                'settleId': settleId,
                'active': active,
                'precision': precision,
                'limits': {},
                'info': market,
            });
        }
        return result;
    }
    parseTrade(trade, market = undefined) {
        const id = this.safeString(trade, 'sid');
        const side = this.safeStringLower(trade, 'side');
        const ts = this.safeInteger(trade, 'timestamp');
        const timestamp = (ts !== undefined) ? (ts * 1000) : undefined;
        const marketId = this.safeString(trade, 'market_addr');
        market = market || this.safeMarket(marketId);
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const sizeInt = this.safeInteger(trade, 'size');
        const priceInt = this.safeInteger(trade, 'price');
        let amount = undefined;
        let price = undefined;
        if (baseDecimals !== undefined && sizeInt !== undefined) {
            amount = sizeInt / Math.pow(10, baseDecimals);
        }
        if (quoteDecimals !== undefined && priceInt !== undefined) {
            price = priceInt / Math.pow(10, quoteDecimals);
        }
        const cost = (amount !== undefined && price !== undefined) ? (amount * price) : undefined;
        return this.safeTrade({
            'id': id,
            'timestamp': timestamp,
            'datetime': (timestamp !== undefined) ? this.iso8601(timestamp) : undefined,
            'symbol': market ? market['symbol'] : undefined,
            'side': side,
            'order': undefined,
            'type': undefined,
            'takerOrMaker': undefined,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': undefined,
            'info': trade,
        }, market);
    }
    async fetchTrades(symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = {
            'market_addr': market['id'],
        };
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PublicGetMarketFills(this.extend(request, params));
        // response: array of FillResponse
        const trades = this.parseTrades(response, market, since, limit);
        return trades;
    }
    async fetchOrderBook(symbol, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = { 'market_addr': market['id'] };
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PublicGetMarketOrders(this.extend(request, params));
        // response: array of OrderResponse with side/price/size ints
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const bidsMap = {};
        const asksMap = {};
        for (let i = 0; i < response.length; i++) {
            const o = response[i];
            const side = this.safeStringLower(o, 'side');
            const priceInt = this.safeInteger(o, 'price');
            const sizeInt = this.safeInteger(o, 'size');
            if (priceInt === undefined || sizeInt === undefined) {
                continue;
            }
            const key = priceInt.toString();
            const sizeFloat = (baseDecimals !== undefined) ? (sizeInt / Math.pow(10, baseDecimals)) : undefined;
            if (sizeFloat === undefined) {
                continue;
            }
            if (side === 'buy') {
                bidsMap[key] = (bidsMap[key] || 0) + sizeFloat;
            }
            else if (side === 'sell') {
                asksMap[key] = (asksMap[key] || 0) + sizeFloat;
            }
        }
        const bidsKeys = Object.keys(bidsMap).map((k) => this.parseToNumeric(k));
        const asksKeys = Object.keys(asksMap).map((k) => this.parseToNumeric(k));
        // Convert price ints to floats using quote decimals
        const toFloatPrice = (p) => ((quoteDecimals !== undefined) ? (p / Math.pow(10, quoteDecimals)) : p);
        const bids = bidsKeys.sort((a, b) => b - a).map((p) => [toFloatPrice(p), bidsMap[p.toString()]]);
        const asks = asksKeys.sort((a, b) => a - b).map((p) => [toFloatPrice(p), asksMap[p.toString()]]);
        const orderbook = { 'bids': bids, 'asks': asks };
        const result = this.parseOrderBook(orderbook, symbol);
        if (limit !== undefined) {
            result['bids'] = result['bids'].slice(0, limit);
            result['asks'] = result['asks'].slice(0, limit);
        }
        return result;
    }
    async fetchBalance(params = {}) {
        // Derive balances from user portfolio endpoint; assumes a single quote asset vault (e.g., USDC)
        this.checkRequiredCredentials(false);
        const response = await this.request('user/portfolio', ['v1', 'private'], 'GET', params);
        // response: PortfolioResponse { vault_balances: [ { asset_addr, balance } ], summary: { total_margin_used } }
        const vaults = this.safeValue(response, 'vault_balances', []);
        const summary = this.safeValue(response, 'summary', {});
        // Try to detect decimals from markets using the first vault asset as quote
        await this.loadMarkets();
        let decimals = undefined;
        let code = 'USDC';
        if (vaults.length > 0) {
            const assetAddr = this.safeString(vaults[0], 'asset_addr');
            // find any market where quoteId == assetAddr
            const marketIds = Object.keys(this.markets_by_id || {});
            for (let i = 0; i < marketIds.length; i++) {
                const m = this.markets_by_id[marketIds[i]];
                const info = m ? (m['info'] || {}) : {};
                const quoteId = this.safeString(info, 'quote_addr');
                if (quoteId === assetAddr) {
                    decimals = this.safeInteger(info, 'quote_decimals');
                    // Best-effort code detection: try to parse from symbol suffix (e.g., BTC/USDC)
                    const sym = this.safeString(m, 'symbol');
                    if (sym) {
                        const parts = sym.split('/');
                        if (parts.length > 1) {
                            code = parts[1].split(':')[0];
                        }
                    }
                    break;
                }
            }
        }
        const scale = (x) => ((decimals !== undefined) ? (x / Math.pow(10, decimals)) : x);
        const totalRaw = this.safeInteger(vaults[0] || {}, 'balance');
        const usedRaw = this.safeInteger(summary, 'total_margin_used');
        const total = (totalRaw !== undefined) ? scale(totalRaw) : undefined;
        const used = (usedRaw !== undefined) ? scale(usedRaw) : 0;
        const free = (total !== undefined && used !== undefined) ? (total - used) : undefined;
        const result = { 'info': response };
        result[code] = {
            'free': free,
            'used': used,
            'total': total,
        };
        return this.safeBalance(result);
    }
    parseOHLCV(ohlcv, market = undefined) {
        const ts = this.safeInteger(ohlcv, 'timestamp');
        const timestamp = (ts !== undefined) ? (ts * 1000) : undefined;
        const open = this.safeNumber(ohlcv, 'open');
        const high = this.safeNumber(ohlcv, 'high');
        const low = this.safeNumber(ohlcv, 'low');
        const close = this.safeNumber(ohlcv, 'close');
        const volume = this.safeNumber(ohlcv, 'volume');
        return [timestamp, open, high, low, close, volume];
    }
    async fetchOHLCV(symbol, timeframe = '1h', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = {
            'market_addr': market['id'],
            'timeframe': timeframe,
        };
        if (since !== undefined) {
            request['start_time'] = this.parseToInt(since / 1000);
        }
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PublicGetMarketCandles(this.extend(request, params));
        // response is array of { timestamp, open, high, low, close, volume, count }
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }
    async fetchTicker(symbol, params = {}) {
        await this.loadMarkets();
        const market = this.market(symbol);
        const response = await this.v1PublicGetMarketCandlesStatsMarketAddr(this.extend({ 'market_addr': market['id'] }, params));
        // MarketStatsResponse: current_price, price_24h_ago, price_change_24h, high_24h, low_24h, volume_24h, trades_24h
        const last = this.safeNumber(response, 'current_price');
        const high = this.safeNumber(response, 'high_24h');
        const low = this.safeNumber(response, 'low_24h');
        const percentage = this.safeNumber(response, 'price_change_24h');
        const baseVolume = this.safeNumber(response, 'volume_24h');
        return this.safeTicker({
            'symbol': market['symbol'],
            'timestamp': undefined,
            'datetime': undefined,
            'high': high,
            'low': low,
            'bid': undefined,
            'bidVolume': undefined,
            'ask': undefined,
            'askVolume': undefined,
            'vwap': undefined,
            'open': this.safeNumber(response, 'price_24h_ago'),
            'close': last,
            'last': last,
            'previousClose': undefined,
            'change': undefined,
            'percentage': percentage,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': undefined,
            'info': response,
        }, market);
    }
    parseOrder(order, market = undefined) {
        const id = this.safeString(order, 'sid');
        const statusRaw = this.safeString(order, 'status');
        const side = this.safeStringLower(order, 'side');
        const type = this.safeStringLower(order, 'type');
        const ts = this.safeInteger(order, 'timestamp');
        const timestamp = (ts !== undefined) ? (ts * 1000) : undefined;
        const marketId = this.safeString(order, 'market_addr');
        market = market || this.safeMarket(marketId);
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const size = this.safeNumber(order, 'size');
        const priceInt = this.safeInteger(order, 'price');
        let amount = size;
        let price = undefined;
        if (baseDecimals !== undefined && size !== undefined) {
            amount = size / Math.pow(10, baseDecimals);
        }
        if (quoteDecimals !== undefined && priceInt !== undefined) {
            price = priceInt / Math.pow(10, quoteDecimals);
        }
        let status = undefined;
        // map to ccxt statuses
        if (statusRaw === 'placed' || statusRaw === 'created' || statusRaw === 'partial_filled') {
            status = 'open';
        }
        else if (statusRaw === 'filled') {
            status = 'closed';
        }
        else if (statusRaw === 'cancelled' || statusRaw === 'rejected') {
            status = 'canceled';
        }
        return this.safeOrder({
            'id': id,
            'clientOrderId': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'lastTradeTimestamp': undefined,
            'status': status,
            'symbol': market ? market['symbol'] : undefined,
            'type': type,
            'timeInForce': undefined,
            'postOnly': undefined,
            'side': side,
            'price': price,
            'stopPrice': undefined,
            'triggerPrice': undefined,
            'cost': undefined,
            'amount': amount,
            'filled': undefined,
            'remaining': undefined,
            'fee': undefined,
            'trades': undefined,
            'info': order,
        }, market);
    }
    async fetchOpenOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = (symbol !== undefined) ? this.market(symbol) : undefined;
        const request = {};
        if (market) {
            request['market_addr'] = market['id'];
        }
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PrivateGetUserOrders(this.extend(request, params));
        const parsed = this.parseOrders(response, market);
        return this.filterByArray(parsed, 'status', ['open'], false);
    }
    async fetchClosedOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = (symbol !== undefined) ? this.market(symbol) : undefined;
        const request = {};
        if (market) {
            request['market_addr'] = market['id'];
        }
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PrivateGetUserOrders(this.extend(request, params));
        const parsed = this.parseOrders(response, market);
        return this.filterByArray(parsed, 'status', ['closed', 'canceled'], false);
    }
    async fetchOrder(id, symbol = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        if (symbol === undefined) {
            throw new ArgumentsRequired(this.id + ' fetchOrder() requires a symbol to be specified');
        }
        const market = this.market(symbol);
        const request = { 'market_addr': market['id'], 'per_page': 50 };
        const response = await this.v1PrivateGetUserOrders(this.extend(request, params));
        for (let i = 0; i < response.length; i++) {
            const item = response[i];
            if (this.safeString(item, 'sid') === id) {
                return this.parseOrder(item, market);
            }
        }
        throw new OrderNotFound(this.id + ' fetchOrder() could not find order id ' + id);
    }
    async createOrder(symbol, type, side, amount, price = undefined, params = {}) {
        // Ekiden requires signed intents over /api/v1/user/intent (Ed25519, Aptos-style BCS payload + nonce + seed)
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = this.market(symbol);
        const hasPayload = this.isValidSignedIntentParams(params, 'order_create');
        let request = {};
        if (hasPayload) {
            const commitProvided = this.safeBool(params, 'commit', false);
            request = this.omit(params, ['commit']);
            const responseProvided = commitProvided ? (await this.v1PrivatePostUserIntentCommit(request)) : (await this.v1PrivatePostUserIntent(request));
            return this.safeOrder({ 'id': undefined, 'symbol': market['symbol'], 'info': responseProvided });
        }
        if (!this.privateKey) {
            throw new NotSupported(this.id + ' createOrder() requires either params { payload, signature, nonce } or exchange.privateKey to sign the intent');
        }
        const leverage = this.safeInteger(params, 'leverage', 1);
        const commitFlag = this.safeBool(params, 'commit', true);
        const order = this.scaleOrderFields(market, side, amount, price, type, leverage);
        const payload = { 'type': 'order_create', 'orders': [order] };
        const nonce = ('nonce' in params) ? this.safeInteger(params, 'nonce') : this.milliseconds();
        request = this.buildSignedIntent(payload, nonce);
        const responseSigned = commitFlag ? (await this.v1PrivatePostUserIntentCommit(request)) : (await this.v1PrivatePostUserIntent(request));
        // If committed, try to resolve the final order from user/orders by seq
        if (commitFlag) {
            const seq = this.safeInteger(responseSigned, 'seq');
            if (seq !== undefined) {
                try {
                    const list = await this.v1PrivateGetUserOrders({ 'market_addr': market['id'], 'per_page': 50 });
                    for (let i = 0; i < list.length; i++) {
                        const it = list[i];
                        if (this.safeInteger(it, 'seq') === seq) {
                            return this.parseOrder(it, market);
                        }
                    }
                }
                catch (e) {
                    // ignore and fallback below
                }
            }
        }
        return this.parseCreateOrderResult(responseSigned, payload, market, amount, price, side, type);
    }
    async cancelOrder(id, symbol = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = (symbol !== undefined) ? this.market(symbol) : undefined;
        const hasPayload = this.isValidSignedIntentParams(params, 'order_cancel');
        let request = {};
        if (hasPayload) {
            const commitProvided = this.safeBool(params, 'commit', false);
            request = this.omit(params, ['commit']);
            const responseProvided = commitProvided ? (await this.v1PrivatePostUserIntentCommit(request)) : (await this.v1PrivatePostUserIntent(request));
            return this.parseCancelOrderResult(responseProvided, id, market);
        }
        if (!this.privateKey) {
            throw new NotSupported(this.id + ' cancelOrder() requires either params { payload, signature, nonce } or exchange.privateKey to sign the intent');
        }
        const commitFlag = this.safeBool(params, 'commit', true);
        // Build cancel payload for a single sid (id)
        const payload = { 'type': 'order_cancel', 'cancels': [{ 'sid': id }] };
        const nonce = ('nonce' in params) ? this.safeInteger(params, 'nonce') : this.milliseconds();
        request = this.buildSignedIntent(payload, nonce);
        const responseSigned = commitFlag ? (await this.v1PrivatePostUserIntentCommit(request)) : (await this.v1PrivatePostUserIntent(request));
        return this.parseCancelOrderResult(responseSigned, id, market);
    }
}
