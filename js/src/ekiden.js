// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

//  ---------------------------------------------------------------------------
import Exchange from './abstract/ekiden.js';
import { DECIMAL_PLACES } from './base/functions/number.js';
import { ArgumentsRequired, OrderNotFound, NotSupported } from './base/errors.js';
import { ed25519 } from './static_dependencies/noble-curves/ed25519.js';
import { eddsa } from './base/functions/crypto.js';
//  ---------------------------------------------------------------------------
/**
 * @class ekiden
 * @augments Exchange
 */
export default class ekiden extends Exchange {
    stripAddrSuffixUpper(value) {
        const up = value.toUpperCase();
        const tag = '-0X';
        const idx = up.indexOf(tag);
        if (idx >= 0) {
            const hexPart = up.slice(idx + tag.length);
            if (hexPart && hexPart.length > 0) {
                let isHex = true;
                for (let j = 0; j < hexPart.length; j++) {
                    const ch = hexPart[j];
                    const isDigit = (ch >= '0') && (ch <= '9');
                    const isAF = (ch >= 'A') && (ch <= 'F');
                    if (!isDigit && !isAF) {
                        isHex = false;
                        break;
                    }
                }
                if (isHex) {
                    return value.slice(0, idx);
                }
            }
        }
        return value;
    }
    normalizeSymbol(symbol) {
        let s = symbol.toUpperCase();
        if (s.indexOf('/') >= 0) {
            const parts = s.split('/');
            const leftRaw = parts[0];
            const rightRaw = parts[1];
            let left = this.stripAddrSuffixUpper(leftRaw);
            let right = rightRaw;
            if (right === 'NONE') {
                if (left.endsWith('-PERP')) {
                    left = left.slice(0, left.length - 5);
                    right = 'USDC';
                }
                else if (left.indexOf('-') >= 0) {
                    const idx = left.indexOf('-');
                    const base = left.slice(0, idx);
                    const quote = left.slice(idx + 1);
                    left = base;
                    right = quote;
                }
            }
            s = left + '/' + right;
        }
        else {
            s = this.stripAddrSuffixUpper(s);
            if (s.endsWith('-PERP')) {
                s = s.slice(0, s.length - 5) + '/USDC';
            }
            if ((s.indexOf('/') < 0) && (s.indexOf('-') >= 0)) {
                const idx = s.indexOf('-');
                s = s.slice(0, idx) + '/' + s.slice(idx + 1);
            }
        }
        return s;
    }
    // --- Intent signing helpers (mirrors ts-sdk buildOrderPayload) ---
    intentSeedHex() {
        // Same SEED used in ts-sdk composeHexPayload
        return 'e2ac4e5688d964270ad876d760c2ebb2d54fb26d93512c790049b6583730d06f';
    }
    serializeStringHex(value) {
        const bin = this.encode(value);
        // Build ULEB128 length manually using numberToLE for cross-language compatibility
        const length = this.binaryLength(bin);
        let v = length;
        let ulebHex = '';
        while (v >= 0x80) {
            const low7 = v % 128;
            const byteVal = low7 + 0x80;
            ulebHex += this.binaryToBase16(this.numberToLE(byteVal, 1));
            v = Math.floor(v / 0x80);
        }
        ulebHex += this.binaryToBase16(this.numberToLE(v, 1));
        const dataHex = this.binaryToBase16(bin);
        return ulebHex + dataHex;
    }
    encodeUleb128Length(len) {
        let v = len;
        let uleb = '';
        while (v >= 0x80) {
            const low7 = v % 128;
            const byteVal = low7 + 0x80;
            uleb += this.binaryToBase16(this.numberToLE(byteVal, 1));
            v = Math.floor(v / 0x80);
        }
        uleb += this.binaryToBase16(this.numberToLE(v, 1));
        return uleb;
    }
    serializeActionPayloadHex(payload) {
        // Mirrors ts-sdk/src/utils/buildOrderPayload.ts
        let out = this.serializeStringHex(this.safeString(payload, 'type'));
        if (payload['type'] === 'leverage_assign') {
            out += this.binaryToBase16(this.numberToLE(this.safeInteger(payload, 'leverage'), 8));
            out += this.serializeStringHex(this.safeString(payload, 'market_addr'));
        }
        else if (payload['type'] === 'order_cancel') {
            const cancels = payload['cancels'] || [];
            // uleb128 length
            const lenHex = this.encodeUleb128Length(cancels.length);
            out += lenHex;
            for (let i = 0; i < cancels.length; i++) {
                out += this.serializeStringHex(this.safeString(cancels[i], 'sid'));
            }
        }
        else if (payload['type'] === 'order_create') {
            const orders = payload['orders'] || [];
            // uleb128 length
            const lenHex = this.encodeUleb128Length(orders.length);
            out += lenHex;
            for (let i = 0; i < orders.length; i++) {
                const o = orders[i];
                out += this.serializeStringHex(this.safeString(o, 'side'));
                out += this.binaryToBase16(this.numberToLE(this.safeInteger(o, 'size'), 8));
                out += this.binaryToBase16(this.numberToLE(this.safeInteger(o, 'price'), 8));
                out += this.binaryToBase16(this.numberToLE(this.safeInteger(o, 'leverage'), 8));
                out += this.serializeStringHex(this.safeString(o, 'type'));
                out += this.serializeStringHex(this.safeString(o, 'market_addr'));
            }
        }
        else {
            throw new NotSupported(this.id + ' unsupported payload type: ' + payload['type']);
        }
        return out;
    }
    buildMessageHex(payloadHex, nonce) {
        return this.intentSeedHex() + payloadHex + this.binaryToBase16(this.numberToLE(nonce, 8));
    }
    signMessageHex(messageHex) {
        const msgBin = this.base16ToBinary(messageHex);
        const pkHex = this.secret.startsWith('0x') ? this.secret.slice(2) : this.secret;
        const secret = this.base16ToBinary(pkHex);
        const sigB64 = eddsa(msgBin, secret, ed25519);
        const sigHex = this.binaryToBase16(this.base64ToBinary(sigB64));
        return '0x' + sigHex;
    }
    buildSignedIntent(payload, nonce) {
        const payloadHex = this.serializeActionPayloadHex(payload);
        const messageHex = this.buildMessageHex(payloadHex, nonce);
        const signature = this.signMessageHex(messageHex);
        return { 'payload': payload, 'nonce': nonce, 'signature': signature };
    }
    isValidSignedIntentParams(params, expectedType = undefined) {
        const payload = this.safeValue(params, 'payload');
        const payloadType = this.safeString(payload, 'type');
        const sig = this.safeString(params, 'signature');
        const hasNonce = ('nonce' in params);
        const hasType = (payloadType !== undefined);
        const typeOk = (expectedType === undefined) ? true : (payloadType === expectedType);
        const sigOk = (sig !== undefined) && (sig.length > 2);
        return (payload !== undefined) && hasType && typeOk && sigOk && hasNonce;
    }
    scaleOrderFields(market, side, amount, price, type, leverage) {
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const sizeInt = (baseDecimals !== undefined && amount !== undefined) ? this.parseToInt(amount * Math.pow(10, baseDecimals)) : undefined;
        const priceInt = (quoteDecimals !== undefined && price !== undefined) ? this.parseToInt(price * Math.pow(10, quoteDecimals)) : 0;
        return {
            'market_addr': market['id'],
            'side': side,
            'size': sizeInt,
            'price': priceInt,
            'type': type,
            'leverage': leverage,
        };
    }
    parseCancelOrderResult(response, requestedId, market = undefined) {
        // Attempt to locate the canceled sid in outputs; fall back to requestedId
        let id = requestedId;
        const output = this.safeValue(response, 'output');
        const outputType = this.safeString(output, 'type');
        if (output && outputType === 'order_cancel') {
            const outputs = this.safeValue(output, 'outputs', []);
            if ((outputs !== undefined) && (outputs.length > 0)) {
                const first = outputs[0];
                const sid = this.safeString(first, 'sid');
                if (sid !== undefined) {
                    id = sid;
                }
            }
        }
        const ts = this.safeInteger(response, 'timestamp');
        const timestamp = (ts !== undefined) ? this.parseToInt(ts) : undefined;
        const datetime = this.iso8601(timestamp);
        const symbolOut = market ? market['symbol'] : undefined;
        return this.safeOrder({
            'id': id,
            'clientOrderId': undefined,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': undefined,
            'status': 'canceled',
            'symbol': symbolOut,
            'type': undefined,
            'timeInForce': undefined,
            'postOnly': undefined,
            'side': undefined,
            'price': undefined,
            'stopPrice': undefined,
            'triggerPrice': undefined,
            'takeProfitPrice': undefined,
            'stopLossPrice': undefined,
            'cost': undefined,
            'amount': undefined,
            'filled': undefined,
            'remaining': undefined,
            'average': undefined,
            'fee': undefined,
            'trades': [],
            'reduceOnly': undefined,
            'info': response,
        }, market);
    }
    parseCreateOrderResult(response, payload, market, amount, price, side, type) {
        // Extract order sid from response.output or response.sid
        let id = undefined;
        const output = this.safeValue(response, 'output');
        const outputType = this.safeString(output, 'type');
        if (output && outputType === 'order_create') {
            const outputs = this.safeValue(output, 'outputs', []);
            if ((outputs !== undefined) && (outputs.length > 0)) {
                id = this.safeString(outputs[0], 'sid');
            }
        }
        if (id === undefined) {
            id = this.safeString(response, 'sid');
        }
        const ts = this.safeInteger(response, 'timestamp');
        const timestamp = (ts !== undefined) ? this.parseToInt(ts) : undefined;
        const datetime = this.iso8601(timestamp);
        const symbolOut = market ? market['symbol'] : undefined;
        return this.safeOrder({
            'id': id,
            'clientOrderId': undefined,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': undefined,
            'status': 'open',
            'symbol': symbolOut,
            'type': type,
            'timeInForce': undefined,
            'postOnly': undefined,
            'side': side,
            'price': price,
            'stopPrice': undefined,
            'triggerPrice': undefined,
            'takeProfitPrice': undefined,
            'stopLossPrice': undefined,
            'cost': undefined,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'average': undefined,
            'fee': undefined,
            'trades': [],
            'reduceOnly': undefined,
            'info': response,
        }, market);
    }
    describe() {
        return this.deepExtend(super.describe(), {
            'id': 'ekiden',
            'name': 'Ekiden',
            'countries': [],
            'rateLimit': 50,
            'version': 'v1',
            'certified': false,
            'pro': false,
            'dex': true,
            'has': {
                'CORS': undefined,
                'spot': true,
                'margin': false,
                'swap': true,
                'future': true,
                'option': false,
                'cancelAllOrders': false,
                'cancelOrder': true,
                'createOrder': true,
                'fetchBalance': true,
                'fetchClosedOrders': true,
                'fetchMarkets': true,
                'fetchMyTrades': false,
                'fetchOHLCV': true,
                'fetchOpenOrders': true,
                'fetchOrder': true,
                'fetchOrderBook': true,
                'fetchPositions': false,
                'fetchTicker': true,
                'fetchTickers': false,
                'fetchTrades': true,
                'sandbox': true,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
            },
            'hostname': 'ekiden.fi',
            'urls': {
                'logo': 'https://raw.githubusercontent.com/ekidenfi/ekiden-docs/refs/heads/main/logo/light.svg',
                'api': {
                    'public': 'https://api.staging.ekiden.fi',
                    'private': 'https://api.staging.ekiden.fi',
                },
                'test': {
                    'public': 'https://api.staging.ekiden.fi',
                    'private': 'https://api.staging.ekiden.fi',
                },
                'www': 'https://ekiden.fi',
                'doc': [
                    'https://docs.ekiden.fi',
                ],
            },
            'precisionMode': DECIMAL_PLACES,
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'market/candles': 1,
                            'market/candles/stats/{market_addr}': 1,
                            'market/market_info': 1,
                            'market/fills': 1,
                            'market/orders': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'user/orders': 1,
                        },
                        'post': {
                            'user/intent': 1,
                            'user/intent/commit': 1,
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'taker': this.parseNumber('0.001'),
                    'maker': this.parseNumber('0.001'),
                },
            },
            'options': {
                'sandboxMode': true,
            },
            'commonCurrencies': {},
            'spot': {
                'extends': 'default',
            },
            'future': {
                'linear': {
                    'extends': 'forPerps',
                },
                'inverse': {
                    'extends': 'forPerps',
                },
            },
        });
    }
    sign(path, api = [], method = 'GET', params = {}, headers = undefined, body = undefined) {
        const version = api[0];
        const scope = api[1]; // 'public' | 'private'
        const fullPath = '/api/' + version + '/' + this.implodeParams(path, params);
        let url = this.urls['api'][scope] + fullPath;
        params = this.omit(params, this.extractParams(path));
        if (method === 'GET') {
            const query = this.urlencode(params);
            if (query.length) {
                url += '?' + query;
            }
        }
        else {
            if (params) {
                body = this.json(params);
            }
        }
        headers = { 'Content-Type': 'application/json' };
        if (scope === 'private' && this.apiKey) {
            headers['Authorization'] = 'Bearer ' + this.apiKey;
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
    async fetchMarkets(params = {}) {
        const response = await this.v1PublicGetMarketMarketInfo(params);
        // response: array of MarketResponse
        const result = [];
        for (let i = 0; i < response.length; i++) {
            const market = response[i];
            const id = this.safeString(market, 'addr');
            const rawSymbol = this.safeString(market, 'symbol');
            const symbol = (rawSymbol !== undefined) ? this.normalizeSymbol(rawSymbol) : undefined;
            const baseId = this.safeString(market, 'base_addr');
            const quoteId = this.safeString(market, 'quote_addr');
            const baseDecimals = this.safeInteger(market, 'base_decimals');
            const quoteDecimals = this.safeInteger(market, 'quote_decimals');
            const linear = true;
            const type = 'swap';
            const settle = undefined;
            const settleId = undefined;
            const active = true;
            const precision = { 'amount': baseDecimals, 'price': quoteDecimals };
            result.push({
                'id': id,
                'symbol': symbol,
                'base': baseId,
                'quote': quoteId,
                'baseId': baseId,
                'quoteId': quoteId,
                'type': type,
                'spot': false,
                'margin': false,
                'swap': true,
                'future': false,
                'option': false,
                'contract': true,
                'linear': linear,
                'inverse': !linear,
                'settle': settle,
                'settleId': settleId,
                'active': active,
                'precision': precision,
                'limits': {},
                'info': market,
            });
        }
        return result;
    }
    parseTrade(trade, market = undefined) {
        const id = this.safeString(trade, 'sid');
        const side = this.safeStringLower(trade, 'side');
        const ts = this.safeInteger(trade, 'timestamp');
        const timestamp = (ts !== undefined) ? this.parseToInt(ts) : undefined;
        const marketId = this.safeString(trade, 'market_addr');
        market = market || this.safeMarket(marketId);
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const sizeInt = this.safeInteger(trade, 'size');
        const priceInt = this.safeInteger(trade, 'price');
        let amount = undefined;
        let price = undefined;
        const datetime = (timestamp !== undefined) ? this.iso8601(timestamp) : undefined;
        if (baseDecimals !== undefined && sizeInt !== undefined) {
            amount = sizeInt / Math.pow(10, baseDecimals);
        }
        if (quoteDecimals !== undefined && priceInt !== undefined) {
            price = priceInt / Math.pow(10, quoteDecimals);
        }
        const cost = (amount !== undefined && price !== undefined) ? (amount * price) : undefined;
        return this.safeTrade({
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': market ? market['symbol'] : undefined,
            'side': side,
            'order': undefined,
            'type': undefined,
            'takerOrMaker': undefined,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': undefined,
            'info': trade,
        }, market);
    }
    async fetchTrades(symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(this.normalizeSymbol(symbol));
        const request = {
            'market_addr': market['id'],
        };
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PublicGetMarketFills(this.extend(request, params));
        // response: array of FillResponse
        const trades = this.parseTrades(response, market, since, limit);
        return trades;
    }
    async fetchOrderBook(symbol, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(this.normalizeSymbol(symbol));
        const request = { 'market_addr': market['id'] };
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PublicGetMarketOrders(this.extend(request, params));
        // response: array of OrderResponse with side/price/size ints
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const bidsMap = {};
        const asksMap = {};
        for (let i = 0; i < response.length; i++) {
            const o = response[i];
            const side = this.safeStringLower(o, 'side');
            const priceInt = this.safeInteger(o, 'price');
            const sizeInt = this.safeInteger(o, 'size');
            if (priceInt === undefined || sizeInt === undefined) {
                continue;
            }
            const key = priceInt.toString();
            const sizeFloat = (baseDecimals !== undefined) ? (sizeInt / Math.pow(10, baseDecimals)) : undefined;
            if (sizeFloat === undefined) {
                continue;
            }
            if (side === 'buy') {
                const prev = this.safeNumber(bidsMap, key, 0);
                bidsMap[key] = this.sum(prev, sizeFloat);
            }
            else if (side === 'sell') {
                const prev = this.safeNumber(asksMap, key, 0);
                asksMap[key] = this.sum(prev, sizeFloat);
            }
        }
        const bids = [];
        const asks = [];
        const bidKeys = Object.keys(bidsMap);
        for (let i = 0; i < bidKeys.length; i++) {
            const k = bidKeys[i];
            const pInt = this.parseToNumeric(k);
            const pFloat = (quoteDecimals !== undefined) ? (pInt / Math.pow(10, quoteDecimals)) : pInt;
            bids.push([pFloat, bidsMap[k]]);
        }
        const askKeys = Object.keys(asksMap);
        for (let i = 0; i < askKeys.length; i++) {
            const k = askKeys[i];
            const pInt = this.parseToNumeric(k);
            const pFloat = (quoteDecimals !== undefined) ? (pInt / Math.pow(10, quoteDecimals)) : pInt;
            asks.push([pFloat, asksMap[k]]);
        }
        const orderbook = { 'bids': bids, 'asks': asks };
        const result = this.parseOrderBook(orderbook, symbol);
        if (limit !== undefined) {
            result['bids'] = result['bids'].slice(0, limit);
            result['asks'] = result['asks'].slice(0, limit);
        }
        return result;
    }
    async fetchBalance(params = {}) {
        // Derive balances from user portfolio endpoint; assumes a single quote asset vault (e.g., USDC)
        this.checkRequiredCredentials();
        const response = await this.request('user/portfolio', ['v1', 'private'], 'GET', params);
        // response: PortfolioResponse { vault_balances: [ { asset_addr, balance } ], summary: { total_margin_used } }
        const vaults = this.safeValue(response, 'vault_balances', []);
        const summary = this.safeValue(response, 'summary', {});
        // Try to detect decimals from markets using the first vault asset as quote
        await this.loadMarkets();
        let decimals = undefined;
        let code = 'USDC';
        if (vaults.length > 0) {
            const assetAddr = this.safeString(vaults[0], 'asset_addr');
            // find any market where quoteId == assetAddr
            const marketIds = Object.keys(this.markets_by_id || {});
            for (let i = 0; i < marketIds.length; i++) {
                let m = this.markets_by_id[marketIds[i]];
                // markets_by_id can map an id to an array of market dicts; use the first
                if (Array.isArray(m) && m.length > 0) {
                    m = m[0];
                }
                const info = m ? (m['info'] || {}) : {};
                const quoteId = this.safeString(info, 'quote_addr');
                if (quoteId === assetAddr) {
                    decimals = this.safeInteger(info, 'quote_decimals');
                    // Best-effort code detection: try to parse from symbol suffix (e.g., BTC/USDC)
                    const sym = this.safeString(m, 'symbol');
                    if (sym) {
                        const parts = sym.split('/');
                        if (parts.length > 1) {
                            code = parts[1].split(':')[0];
                        }
                    }
                    break;
                }
            }
        }
        const totalRaw = this.safeInteger(vaults[0] || {}, 'balance');
        const usedRaw = this.safeInteger(summary, 'total_margin_used');
        let total = undefined;
        if (totalRaw !== undefined) {
            total = (decimals !== undefined) ? (totalRaw / Math.pow(10, decimals)) : totalRaw;
        }
        let used = 0;
        if (usedRaw !== undefined) {
            used = (decimals !== undefined) ? (usedRaw / Math.pow(10, decimals)) : usedRaw;
        }
        const free = (total !== undefined && used !== undefined) ? (total - used) : undefined;
        const result = { 'info': response };
        result[code] = {
            'free': free,
            'used': used,
            'total': total,
        };
        return this.safeBalance(result);
    }
    parseOHLCV(ohlcv, market = undefined) {
        const ts = this.safeInteger(ohlcv, 'timestamp');
        const timestamp = (ts !== undefined) ? (ts * 1000) : undefined;
        const open = this.safeNumber(ohlcv, 'open');
        const high = this.safeNumber(ohlcv, 'high');
        const low = this.safeNumber(ohlcv, 'low');
        const close = this.safeNumber(ohlcv, 'close');
        const volume = this.safeNumber(ohlcv, 'volume');
        return [timestamp, open, high, low, close, volume];
    }
    async fetchOHLCV(symbol, timeframe = '1h', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        const market = this.market(this.normalizeSymbol(symbol));
        const request = {
            'market_addr': market['id'],
            'timeframe': timeframe,
        };
        if (since !== undefined) {
            request['start_time'] = this.parseToInt(since / 1000);
        }
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PublicGetMarketCandles(this.extend(request, params));
        // response is array of { timestamp, open, high, low, close, volume, count }
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }
    async fetchTicker(symbol, params = {}) {
        await this.loadMarkets();
        const market = this.market(this.normalizeSymbol(symbol));
        const response = await this.v1PublicGetMarketCandlesStatsMarketAddr(this.extend({ 'market_addr': market['id'] }, params));
        // MarketStatsResponse: current_price, price_24h_ago, price_change_24h, high_24h, low_24h, volume_24h (quote volume), trades_24h
        const last = this.safeNumber(response, 'current_price');
        const high = this.safeNumber(response, 'high_24h');
        const low = this.safeNumber(response, 'low_24h');
        const percentage = this.safeNumber(response, 'price_change_24h');
        const rawQuoteVolume = this.safeNumber(response, 'volume_24h');
        const quoteVolume = ((rawQuoteVolume === undefined) || !isFinite(rawQuoteVolume)) ? 0 : rawQuoteVolume;
        let baseVolume = 0;
        if ((quoteVolume > 0) && (last !== undefined) && (last > 0)) {
            baseVolume = quoteVolume / last;
        }
        return this.safeTicker({
            'symbol': market['symbol'],
            'timestamp': undefined,
            'datetime': undefined,
            'high': high,
            'low': low,
            'bid': undefined,
            'bidVolume': undefined,
            'ask': undefined,
            'askVolume': undefined,
            'vwap': undefined,
            'open': this.safeNumber(response, 'price_24h_ago'),
            'close': last,
            'last': last,
            'previousClose': undefined,
            'change': undefined,
            'percentage': percentage,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': response,
        }, market);
    }
    parseOrder(order, market = undefined) {
        const id = this.safeString(order, 'sid');
        const statusRaw = this.safeString(order, 'status');
        const side = this.safeStringLower(order, 'side');
        const type = this.safeStringLower(order, 'type');
        const ts = this.safeInteger(order, 'timestamp');
        const timestamp = (ts !== undefined) ? this.parseToInt(ts) : undefined;
        const marketId = this.safeString(order, 'market_addr');
        market = market || this.safeMarket(marketId);
        const baseDecimals = this.safeInteger(market['info'] || {}, 'base_decimals');
        const quoteDecimals = this.safeInteger(market['info'] || {}, 'quote_decimals');
        const size = this.safeNumber(order, 'size');
        const priceInt = this.safeInteger(order, 'price');
        let amount = size;
        let price = undefined;
        if (baseDecimals !== undefined && size !== undefined) {
            amount = size / Math.pow(10, baseDecimals);
        }
        if (quoteDecimals !== undefined && priceInt !== undefined) {
            price = priceInt / Math.pow(10, quoteDecimals);
        }
        let status = undefined;
        // map to ccxt statuses
        if (statusRaw === 'placed' || statusRaw === 'created' || statusRaw === 'partial_filled') {
            status = 'open';
        }
        else if (statusRaw === 'filled') {
            status = 'closed';
        }
        else if (statusRaw === 'cancelled' || statusRaw === 'rejected') {
            status = 'canceled';
        }
        return this.safeOrder({
            'id': id,
            'clientOrderId': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'lastTradeTimestamp': undefined,
            'status': status,
            'symbol': market ? market['symbol'] : undefined,
            'type': type,
            'timeInForce': undefined,
            'postOnly': undefined,
            'side': side,
            'price': price,
            'stopPrice': undefined,
            'triggerPrice': undefined,
            'cost': undefined,
            'amount': amount,
            'filled': undefined,
            'remaining': undefined,
            'fee': undefined,
            'trades': undefined,
            'info': order,
        }, market);
    }
    async fetchOpenOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = (symbol !== undefined) ? this.market(this.normalizeSymbol(symbol)) : undefined;
        const request = {};
        if (market) {
            request['market_addr'] = market['id'];
        }
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PrivateGetUserOrders(this.extend(request, params));
        const parsed = this.parseOrders(response, market);
        return this.filterByArray(parsed, 'status', ['open'], false);
    }
    async fetchClosedOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = (symbol !== undefined) ? this.market(this.normalizeSymbol(symbol)) : undefined;
        const request = {};
        if (market) {
            request['market_addr'] = market['id'];
        }
        if (limit !== undefined) {
            request['per_page'] = limit;
        }
        const response = await this.v1PrivateGetUserOrders(this.extend(request, params));
        const parsed = this.parseOrders(response, market);
        return this.filterByArray(parsed, 'status', ['closed', 'canceled'], false);
    }
    async fetchOrder(id, symbol = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        if (symbol === undefined) {
            throw new ArgumentsRequired(this.id + ' fetchOrder() requires a symbol to be specified');
        }
        const market = this.market(this.normalizeSymbol(symbol));
        const request = { 'market_addr': market['id'], 'per_page': 50 };
        const response = await this.v1PrivateGetUserOrders(this.extend(request, params));
        for (let i = 0; i < response.length; i++) {
            const item = response[i];
            if (this.safeString(item, 'sid') === id) {
                return this.parseOrder(item, market);
            }
        }
        throw new OrderNotFound(this.id + ' fetchOrder() could not find order id ' + id);
    }
    async createOrder(symbol, type, side, amount, price = undefined, params = {}) {
        // Ekiden requires signed intents over /api/v1/user/intent (Ed25519, Aptos-style BCS payload + nonce + seed)
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = this.market(this.normalizeSymbol(symbol));
        const hasPayload = this.isValidSignedIntentParams(params, 'order_create');
        let request = {};
        if (hasPayload) {
            const commitProvided = this.safeBool(params, 'commit', false);
            request = this.omit(params, ['commit']);
            let responseProvided = undefined;
            if (commitProvided) {
                responseProvided = await this.v1PrivatePostUserIntentCommit(request);
            }
            else {
                responseProvided = await this.v1PrivatePostUserIntent(request);
            }
            return this.safeOrder({ 'id': undefined, 'symbol': market['symbol'], 'info': responseProvided });
        }
        if (!this.secret) {
            throw new NotSupported(this.id + ' createOrder() requires either params { payload, signature, nonce } or exchange.secret to sign the intent');
        }
        const leverage = this.safeInteger(params, 'leverage', 1);
        const commitFlag = this.safeBool(params, 'commit', true);
        const order = this.scaleOrderFields(market, side, amount, price, type, leverage);
        const payload = { 'type': 'order_create', 'orders': [order] };
        const nonce = ('nonce' in params) ? this.safeInteger(params, 'nonce') : this.milliseconds();
        request = this.buildSignedIntent(payload, nonce);
        let responseSigned = undefined;
        if (commitFlag) {
            responseSigned = await this.v1PrivatePostUserIntentCommit(request);
        }
        else {
            responseSigned = await this.v1PrivatePostUserIntent(request);
        }
        // If committed, try to resolve the final order from user/orders by seq
        if (commitFlag) {
            const seq = this.safeInteger(responseSigned, 'seq');
            if (seq !== undefined) {
                try {
                    const list = await this.v1PrivateGetUserOrders({ 'market_addr': market['id'], 'per_page': 50 });
                    for (let i = 0; i < list.length; i++) {
                        const it = list[i];
                        if (this.safeInteger(it, 'seq') === seq) {
                            return this.parseOrder(it, market);
                        }
                    }
                }
                catch (e) {
                    // ignore and fallback below
                    // eslint-disable-next-line no-unused-vars
                    const _ = e; // no-op to satisfy transpilers
                }
            }
        }
        return this.parseCreateOrderResult(responseSigned, payload, market, amount, price, side, type);
    }
    async cancelOrder(id, symbol = undefined, params = {}) {
        await this.loadMarkets();
        this.checkRequiredCredentials(false);
        const market = (symbol !== undefined) ? this.market(this.normalizeSymbol(symbol)) : undefined;
        const hasPayload = this.isValidSignedIntentParams(params, 'order_cancel');
        let request = {};
        if (hasPayload) {
            const commitProvided = this.safeBool(params, 'commit', false);
            request = this.omit(params, ['commit']);
            let responseProvided = undefined;
            if (commitProvided) {
                responseProvided = await this.v1PrivatePostUserIntentCommit(request);
            }
            else {
                responseProvided = await this.v1PrivatePostUserIntent(request);
            }
            return this.parseCancelOrderResult(responseProvided, id, market);
        }
        if (!this.secret) {
            throw new NotSupported(this.id + ' cancelOrder() requires either params { payload, signature, nonce } or exchange.secret to sign the intent');
        }
        const commitFlag = this.safeBool(params, 'commit', true);
        // Build cancel payload for a single sid (id)
        const payload = { 'type': 'order_cancel', 'cancels': [{ 'sid': id }] };
        const nonce = ('nonce' in params) ? this.safeInteger(params, 'nonce') : this.milliseconds();
        request = this.buildSignedIntent(payload, nonce);
        let responseSigned2 = undefined;
        if (commitFlag) {
            responseSigned2 = await this.v1PrivatePostUserIntentCommit(request);
        }
        else {
            responseSigned2 = await this.v1PrivatePostUserIntent(request);
        }
        return this.parseCancelOrderResult(responseSigned2, id, market);
    }
}
