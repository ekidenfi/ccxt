# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.ekiden import ImplicitAPI
import math
from ccxt.base.types import Any, Balances, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Str, Ticker, Trade
from typing import List
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.decimal_to_precision import DECIMAL_PLACES


class ekiden(Exchange, ImplicitAPI):

    def normalize_symbol(self, symbol: str) -> str:
        s = symbol.upper()
        if s.find('/') >= 0:
            parts = s.split('/')
            leftRaw = parts[0]
            rightRaw = parts[1]
            left = leftRaw.replace(/-0x[a-f0-9]+$/i, '')
            right = rightRaw
            if right == 'NONE':
                if /-PERP$/i.test(left):
                    left = left.replace(/-PERP$/i, '')
                    right = 'USDC'
                elif left.find('-') >= 0:
                    idx = left.find('-')
                    base = left[0:idx]
                    quote = left[idx + 1:]
                    left = base
                    right = quote
            s = left + '/' + right
        else:
            s = s.replace(/-0x[a-f0-9]+$/i, '')
            s = s.replace(/-PERP$/i, '/USDC')
            if (s.find('/') < 0) and (s.find('-') >= 0):
                idx = s.find('-')
                s = s[0:idx] + '/' + s[idx + 1:]
        return s

    def intent_seed(self) -> Uint8Array:
        # Same SEED used in ts-sdk composeHexPayload
        return new Uint8Array([226, 172, 78, 86, 136, 217, 100, 39, 10, 216, 118, 215, 96, 194, 235, 178, 213, 79, 178, 109, 147, 81, 44, 121, 0, 73, 182, 88, 55, 48, 208, 111])

    def encode_uleb128(self, value: float) -> Uint8Array:
        out: List[number] = []
        v = value
        while(v >= 0x80):
            low7 = v % 128
            out.append(low7 + 0x80)
            v = int(math.floor(v / 0x80))
        out.append(v)
        return new Uint8Array(out)

    def encode_u64_le(self, value: float | bigint) -> Uint8Array:
        x = BigInt(value)
        out = Uint8Array(8)
        for i in range(0, 8):
            divisor = 256n ** BigInt(i)
            out[i] = Number((x / divisor) % 256n)
        return out

    def concat_bytes(self, arrays: List[Uint8Array]) -> Uint8Array:
        total = arrays.reduce((acc, a) => acc + len(a), 0)
        out = Uint8Array(total)
        offset = 0
        for i in range(0, len(arrays)):
            out.set(arrays[i], offset)
            offset += len(arrays[i])
        return out

    def serialize_string(self, value: str) -> Uint8Array:
        enc = TextEncoder()
        bytes = enc.encode(value)
        return self.concat_bytes([self.encode_uleb128(len(bytes)), bytes])

    def serialize_action_payload(self, payload: dict) -> Uint8Array:
        # Mirrors ts-sdk/src/utils/buildOrderPayload.ts
        chunks: List[Uint8Array] = [self.serialize_string(self.safe_string(payload, 'type'))]
        if payload['type'] == 'leverage_assign':
            chunks.append(self.encode_u64_le(BigInt(self.safe_integer(payload, 'leverage'))))
            chunks.append(self.serialize_string(self.safe_string(payload, 'market_addr')))
        elif payload['type'] == 'order_cancel':
            cancels = payload['cancels'] or []
            chunks.append(self.encode_uleb128(len(cancels)))
            for i in range(0, len(cancels)):
                chunks.append(self.serialize_string(self.safe_string(cancels[i], 'sid')))
        elif payload['type'] == 'order_create':
            orders = payload['orders'] or []
            chunks.append(self.encode_uleb128(len(orders)))
            for i in range(0, len(orders)):
                o = orders[i]
                chunks.append(self.serialize_string(self.safe_string(o, 'side')))
                chunks.append(self.encode_u64_le(BigInt(self.safe_integer(o, 'size'))))
                chunks.append(self.encode_u64_le(BigInt(self.safe_integer(o, 'price'))))
                chunks.append(self.encode_u64_le(BigInt(self.safe_integer(o, 'leverage'))))
                chunks.append(self.serialize_string(self.safe_string(o, 'type')))
                chunks.append(self.serialize_string(self.safe_string(o, 'market_addr')))
        else:
            raise NotSupported(self.id + ' unsupported payload type: ' + payload['type'])
        return self.concat_bytes(chunks)

    def build_message(self, payloadBytes: Uint8Array, nonce: float) -> Uint8Array:
        return self.concat_bytes([self.intent_seed(), payloadBytes, self.encode_u64_le(BigInt(nonce))])

    def bytes_to_hex(self, arr: Uint8Array) -> str:
        hex: List[str] = Array(len(arr))
        for i in range(0, len(arr)):
            hex[i] = arr[i].toString(16).rjust(2, '0')
        return '0x' + ''.join(hex)

    def sign_message(self, message: Uint8Array) -> str:
        privateKeyHex = self.privateKey
        value = privateKeyHex[2:] if privateKeyHex.startswith('0x') else privateKeyHex
        pk = Uint8Array(len(value) / 2)
        for i in range(0, len(pk)):
            pk[i] = int(value[i * 2:i * 2 + 2], 16)
        sig = ed25519.sign(message, pk)
        return self.bytes_to_hex(sig)

    def build_signed_intent(self, payload: dict, nonce: float) -> dict:
        payloadBytes = self.serialize_action_payload(payload)
        message = self.build_message(payloadBytes, nonce)
        signature = self.sign_message(message)
        return {'payload': payload, 'nonce': nonce, 'signature': signature}

    def is_valid_signed_intent_params(self, params: dict, expectedType: str = None) -> bool:
        payload = self.safe_value(params, 'payload')
        payloadType = self.safe_string(payload, 'type')
        sig = self.safe_string(params, 'signature')
        hasNonce = ('nonce' in params)
        hasType = (payloadType is not None)
        typeOk = True if (expectedType is None) else (payloadType == expectedType)
        sigOk = (sig is not None) and (len(sig) > 2)
        return not !(payload and hasType and typeOk and sigOk and hasNonce)

    def scale_order_fields(self, market: Market, side: OrderSide, amount: float, price: Num, type: OrderType, leverage: float) -> dict:
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.parse_to_int(amount * math.pow(10, baseDecimals)) if (baseDecimals is not None and amount is not None) else None
        priceInt = self.parse_to_int(price * math.pow(10, quoteDecimals)) if (quoteDecimals is not None and price is not None) else 0
        return {
            'market_addr': market['id'],
            'side': side,
            'size': sizeInt,
            'price': priceInt,
            'type': type,
            'leverage': leverage,
        }

    def parse_cancel_order_result(self, response: dict, requestedId: str, market: Market = None) -> Order:
        # Attempt to locate the canceled sid in outputs; fall back to requestedId
        id = requestedId
        output = self.safe_value(response, 'output')
        outputType = self.safe_string(output, 'type')
        if output and outputType == 'order_cancel':
            outputs = self.safe_value(output, 'outputs', [])
            if (outputs is not None) and (len(outputs) > 0):
                first = outputs[0]
                sid = self.safe_string(first, 'sid')
                if sid is not None:
                    id = sid
        ts = self.safe_integer(response, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        return self.iso8601(timestamp) if self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': (timestamp is not None) else None,
            'lastTradeTimestamp': None,
            'status': 'canceled',
            'symbol': market['symbol'] if market else None,
            'type': None,
            'timeInForce': None,
            'postOnly': None,
            'side': None,
            'price': None,
            'stopPrice': None,
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'cost': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'average': None,
            'fee': None,
            'trades': [],
            'reduceOnly': None,
            'info': response,
        }, market)

    def parse_create_order_result(self, response: dict, payload: dict, market: Market, amount: float, price: Num, side: OrderSide, type: OrderType) -> Order:
        # Extract order sid from response.output or response.sid
        id = None
        output = self.safe_value(response, 'output')
        outputType = self.safe_string(output, 'type')
        if output and outputType == 'order_create':
            outputs = self.safe_value(output, 'outputs', [])
            if (outputs is not None) and (len(outputs) > 0):
                id = self.safe_string(outputs[0], 'sid')
        if id is None:
            id = self.safe_string(response, 'sid')
        ts = self.safe_integer(response, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        # Best-effort mapped order
        return self.iso8601(timestamp) if self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': (timestamp is not None) else None,
            'lastTradeTimestamp': None,
            'status': 'open',
            'symbol': market['symbol'] if market else None,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'cost': None,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'average': None,
            'fee': None,
            'trades': [],
            'reduceOnly': None,
            'info': response,
        }, market)

    def describe(self) -> Any:
        return self.deep_extend(super(ekiden, self).describe(), {
            'id': 'ekiden',
            'name': 'Ekiden',
            'countries': [],
            'rateLimit': 50,
            'version': 'v1',
            'certified': False,
            'pro': False,
            'dex': True,
            'has': {
                'CORS': None,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchPositions': False,
                'fetchTicker': True,
                'fetchTickers': False,
                'fetchTrades': True,
                'sandbox': True,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
            },
            'urls': {
                'logo': 'https://raw.githubusercontent.com/ekidenfi/ekiden-docs/refs/heads/main/logo/dark.svg',
                'api': {
                    'public': 'https://api.ekiden.fi',
                    'private': 'https://api.ekiden.fi',
                },
                'www': 'https://ekiden.fi',
                'doc': [
                    'https://docs.ekiden.fi',
                ],
            },
            'precisionMode': DECIMAL_PLACES,
            'requiredCredentials': {
                'apiKey': False,
                'secret': False,
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'market/candles': 1,
                            'market/candles/stats/{market_addr}': 1,
                            'market/market_info': 1,
                            'market/fills': 1,
                            'market/orders': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'user/orders': 1,
                        },
                        'post': {
                            'user/intent': 1,
                            'user/intent/commit': 1,
                        },
                    },
                },
            },
            'options': {
                'sandboxMode': False,
            },
            'commonCurrencies': {
            },
        })

    def sign(self, path, api=[], method='GET', params={}, headers=None, body=None):
        version = api[0]
        scope = api[1]  # 'public' | 'private'
        fullPath = '/api/' + version + '/' + self.implode_params(path, params)
        url = self.urls['api'][scope] + fullPath
        params = self.omit(params, self.extract_params(path))
        if method == 'GET':
            query = self.urlencode(params)
            if len(query):
                url += '?' + query
        else:
            if params:
                body = self.json(params)
        headers = {'Content-Type': 'application/json'}
        if scope == 'private' and self.apiKey:
            headers['Authorization'] = 'Bearer ' + self.apiKey
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def fetch_markets(self, params={}) -> List[Market]:
        response = await self.v1PublicGetMarketMarketInfo(params)
        # response: array of MarketResponse
        result: List[Market] = []
        for i in range(0, len(response)):
            market = response[i]
            id = self.safe_string(market, 'addr')
            rawSymbol = self.safe_string(market, 'symbol')
            symbol = self.normalize_symbol(rawSymbol) if (rawSymbol is not None) else None
            baseId = self.safe_string(market, 'base_addr')
            quoteId = self.safe_string(market, 'quote_addr')
            baseDecimals = self.safe_integer(market, 'base_decimals')
            quoteDecimals = self.safe_integer(market, 'quote_decimals')
            linear = True
            type = 'swap'
            settle = None
            settleId = None
            active = True
            precision = {'amount': baseDecimals, 'price': quoteDecimals}
            result.append({
                'id': id,
                'symbol': symbol,
                'base': baseId,
                'quote': quoteId,
                'baseId': baseId,
                'quoteId': quoteId,
                'type': type,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'contract': True,
                'linear': linear,
                'inverse': not linear,
                'settle': settle,
                'settleId': settleId,
                'active': active,
                'precision': precision,
                'limits': {},
                'info': market,
            })
        return result

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        id = self.safe_string(trade, 'sid')
        side = self.safe_string_lower(trade, 'side')
        ts = self.safe_integer(trade, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        marketId = self.safe_string(trade, 'market_addr')
        market = market or self.safe_market(marketId)
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.safe_integer(trade, 'size')
        priceInt = self.safe_integer(trade, 'price')
        amount = None
        price = None
        if baseDecimals is not None and sizeInt is not None:
            amount = sizeInt / math.pow(10, baseDecimals)
        if quoteDecimals is not None and priceInt is not None:
            price = priceInt / math.pow(10, quoteDecimals)
        cost = (amount * price) if (amount is not None and price is not None) else None
        return self.iso8601(timestamp) if self.safe_trade({
            'id': id,
            'timestamp': timestamp,
            'datetime': (timestamp is not None) else None,
            'symbol': market['symbol'] if market else None,
            'side': side,
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
            'info': trade,
        }, market)

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {
            'market_addr': market['id'],
        }
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PublicGetMarketFills(self.extend(request, params))
        # response: array of FillResponse
        trades = self.parse_trades(response, market, since, limit)
        return trades

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {'market_addr': market['id']}
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PublicGetMarketOrders(self.extend(request, params))
        # response: array of OrderResponse with side/price/size ints
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        bidsMap: dict = {}
        asksMap: dict = {}
        for i in range(0, len(response)):
            o = response[i]
            side = self.safe_string_lower(o, 'side')
            priceInt = self.safe_integer(o, 'price')
            sizeInt = self.safe_integer(o, 'size')
            if priceInt is None or sizeInt is None:
                continue
            key = str(priceInt)
            sizeFloat = (sizeInt / math.pow(10, baseDecimals)) if (baseDecimals is not None) else None
            if sizeFloat is None:
                continue
            if side == 'buy':
                bidsMap[key] = (bidsMap[key] or 0) + sizeFloat
            elif side == 'sell':
                asksMap[key] = (asksMap[key] or 0) + sizeFloat
        bidsKeys = list(bidsMap).map((k) => self.parse_to_numeric(k).keys())
        asksKeys = list(asksMap).map((k) => self.parse_to_numeric(k).keys())
        # Convert price ints to floats using quote decimals
        toFloatPrice = (p: number) =>(p / math.pow(10, quoteDecimals)) if ((quoteDecimals is not None) else p)
        bids = bidsKeys.sort((a, b) => b - a).map((p) => [toFloatPrice(p), str(bidsMap[p)]])
        asks = asksKeys.sort((a, b) => a - b).map((p) => [toFloatPrice(p), str(asksMap[p)]])
        orderbook = {'bids': bids, 'asks': asks}
        result = self.parse_order_book(orderbook, symbol)
        if limit is not None:
            result['bids'] = result['bids'][0:limit]
            result['asks'] = result['asks'][0:limit]
        return result

    async def fetch_balance(self, params={}) -> Balances:
        # Derive balances from user portfolio endpoint; assumes a single quote asset vault(e.g., USDC)
        self.check_required_credentials(False)
        response = await self.request('user/portfolio', ['v1', 'private'], 'GET', params)
        # response: PortfolioResponse {vault_balances: [{asset_addr, balance}], summary: {total_margin_used}}
        vaults = self.safe_value(response, 'vault_balances', [])
        summary = self.safe_value(response, 'summary', {})
        # Try to detect decimals from markets using the first vault asset
        await self.load_markets()
        decimals: number = None
        code: str = 'USDC'
        if len(vaults) > 0:
            assetAddr = self.safe_string(vaults[0], 'asset_addr')
            # find any market where quoteId == assetAddr
            marketIds = list(self.markets_by_id or {}.keys())
            for i in range(0, len(marketIds)):
                m = self.markets_by_id[marketIds[i]]
                info = (m['info'] or {}) if m else {}
                quoteId = self.safe_string(info, 'quote_addr')
                if quoteId == assetAddr:
                    decimals = self.safe_integer(info, 'quote_decimals')
                    # Best-effort code detection: try to parse from symbol suffix(e.g., BTC/USDC)
                    sym = self.safe_string(m, 'symbol')
                    if sym:
                        parts = sym.split('/')
                        if len(parts) > 1:
                            code = parts[1].split(':')[0]
                    break
        scale = (x: number) =>(x / math.pow(10, decimals)) if ((decimals is not None) else x)
        totalRaw = self.safe_integer(vaults[0] or {}, 'balance')
        usedRaw = self.safe_integer(summary, 'total_margin_used')
        total = scale(totalRaw) if (totalRaw is not None) else None
        used = scale(usedRaw) if (usedRaw is not None) else 0
        free = (total - used) if (total is not None and used is not None) else None
        result: dict = {'info': response}
        result[code] = {
            'free': free,
            'used': used,
            'total': total,
        }
        return self.safe_balance(result)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        ts = self.safe_integer(ohlcv, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        open = self.safe_number(ohlcv, 'open')
        high = self.safe_number(ohlcv, 'high')
        low = self.safe_number(ohlcv, 'low')
        close = self.safe_number(ohlcv, 'close')
        volume = self.safe_number(ohlcv, 'volume')
        return [timestamp, open, high, low, close, volume]

    async def fetch_ohlcv(self, symbol: str, timeframe='1h', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {
            'market_addr': market['id'],
            'timeframe': timeframe,
        }
        if since is not None:
            request['start_time'] = self.parse_to_int(since / 1000)
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PublicGetMarketCandles(self.extend(request, params))
        # response is array of {timestamp, open, high, low, close, volume, count}
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        response = await self.v1PublicGetMarketCandlesStatsMarketAddr(self.extend({'market_addr': market['id']}, params))
        # MarketStatsResponse: current_price, price_24h_ago, price_change_24h, high_24h, low_24h, volume_24h, trades_24h
        last = self.safe_number(response, 'current_price')
        high = self.safe_number(response, 'high_24h')
        low = self.safe_number(response, 'low_24h')
        percentage = self.safe_number(response, 'price_change_24h')
        baseVolume = self.safe_number(response, 'volume_24h')
        return self.safe_ticker({
            'symbol': market['symbol'],
            'timestamp': None,
            'datetime': None,
            'high': high,
            'low': low,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': self.safe_number(response, 'price_24h_ago'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': percentage,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': None,
            'info': response,
        }, market)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        id = self.safe_string(order, 'sid')
        statusRaw = self.safe_string(order, 'status')
        side = self.safe_string_lower(order, 'side')
        type = self.safe_string_lower(order, 'type')
        ts = self.safe_integer(order, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        marketId = self.safe_string(order, 'market_addr')
        market = market or self.safe_market(marketId)
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        size = self.safe_number(order, 'size')
        priceInt = self.safe_integer(order, 'price')
        amount = size
        price = None
        if baseDecimals is not None and size is not None:
            amount = size / math.pow(10, baseDecimals)
        if quoteDecimals is not None and priceInt is not None:
            price = priceInt / math.pow(10, quoteDecimals)
        status = None
        # map to ccxt statuses
        if statusRaw == 'placed' or statusRaw == 'created' or statusRaw == 'partial_filled':
            status = 'open'
        elif statusRaw == 'filled':
            status = 'closed'
        elif statusRaw == 'cancelled' or statusRaw == 'rejected':
            status = 'canceled'
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': market['symbol'] if market else None,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'cost': None,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'fee': None,
            'trades': None,
            'info': order,
        }, market)

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        request: dict = {}
        if market:
            request['market_addr'] = market['id']
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PrivateGetUserOrders(self.extend(request, params))
        parsed = self.parse_orders(response, market)
        return self.filter_by_array(parsed, 'status', ['open'], False)

    async def fetch_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        request: dict = {}
        if market:
            request['market_addr'] = market['id']
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PrivateGetUserOrders(self.extend(request, params))
        parsed = self.parse_orders(response, market)
        return self.filter_by_array(parsed, 'status', ['closed', 'canceled'], False)

    async def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        self.check_required_credentials(False)
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol to be specified')
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {'market_addr': market['id'], 'per_page': 50}
        response = await self.v1PrivateGetUserOrders(self.extend(request, params))
        for i in range(0, len(response)):
            item = response[i]
            if self.safe_string(item, 'sid') == id:
                return self.parse_order(item, market)
        raise OrderNotFound(self.id + ' fetchOrder() could not find order id ' + id)

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        # Ekiden requires signed intents over /api/v1/user/intent(Ed25519, Aptos-style BCS payload + nonce + seed)
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol))
        hasPayload = self.is_valid_signed_intent_params(params, 'order_create')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = (await self.v1PrivatePostUserIntentCommit(request)) if commitProvided else (await self.v1PrivatePostUserIntent(request))
            return self.safe_order({'id': None, 'symbol': market['symbol'], 'info': responseProvided})
        if not self.privateKey:
            raise NotSupported(self.id + ' createOrder() requires either params {payload, signature, nonce} or exchange.privateKey to sign the intent')
        leverage = self.safe_integer(params, 'leverage', 1)
        commitFlag = self.safe_bool(params, 'commit', True)
        order = self.scale_order_fields(market, side, amount, price, type, leverage)
        payload: dict = {'type': 'order_create', 'orders': [order]}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned = (await self.v1PrivatePostUserIntentCommit(request)) if commitFlag else (await self.v1PrivatePostUserIntent(request))
        # If committed, try to resolve the final order from user/orders by seq
        if commitFlag:
            seq = self.safe_integer(responseSigned, 'seq')
            if seq is not None:
                try:
                    list = await self.v1PrivateGetUserOrders({'market_addr': market['id'], 'per_page': 50})
                    for i in range(0, len(list)):
                        it = list[i]
                        if self.safe_integer(it, 'seq') == seq:
                            return self.parse_order(it, market)
                except Exception as e:
                    # ignore and fallback below
        return self.parse_create_order_result(responseSigned, payload, market, amount, price, side, type)

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        hasPayload = self.is_valid_signed_intent_params(params, 'order_cancel')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = (await self.v1PrivatePostUserIntentCommit(request)) if commitProvided else (await self.v1PrivatePostUserIntent(request))
            return self.parse_cancel_order_result(responseProvided, id, market)
        if not self.privateKey:
            raise NotSupported(self.id + ' cancelOrder() requires either params {payload, signature, nonce} or exchange.privateKey to sign the intent')
        commitFlag = self.safe_bool(params, 'commit', True)
        # Build cancel payload for a single sid(id)
        payload: dict = {'type': 'order_cancel', 'cancels': [{'sid': id}]}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned = (await self.v1PrivatePostUserIntentCommit(request)) if commitFlag else (await self.v1PrivatePostUserIntent(request))
        return self.parse_cancel_order_result(responseSigned, id, market)
