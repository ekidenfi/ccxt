# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.ekiden import ImplicitAPI
import math
from ccxt.base.types import Any, Balances, Bool, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Position, Str, Strings, Ticker, Tickers, Trade
from typing import List
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.decimal_to_precision import DECIMAL_PLACES


class ekiden(Exchange, ImplicitAPI):

    def strip_addr_suffix_upper(self, value: str) -> str:
        up = value.upper()
        tag = '-0X'
        idx = up.find(tag)
        if idx >= 0:
            hexPart = up[idx + len(tag):]
            if hexPart and len(hexPart) > 0:
                isHex = True
                for j in range(0, len(hexPart)):
                    ch = hexPart[j]
                    isDigit = (ch >= '0') and (ch <= '9')
                    isAF = (ch >= 'A') and (ch <= 'F')
                    if not isDigit and not isAF:
                        isHex = False
                        break
                if isHex:
                    return value[0:idx]
        return value

    def normalize_symbol(self, symbol: str) -> str:
        # if symbol.includes(':'):
        #     return symbol
        # }
        s = symbol.upper()
        if s.find('/') >= 0:
            parts = s.split('/')
            leftRaw = parts[0]
            rightRaw = parts[1]
            left = self.strip_addr_suffix_upper(leftRaw)
            right = rightRaw
            if right == 'NONE':
                if left.endswith('-PERP'):
                    left = left[0:len(left) - 5]
                    right = 'USDC'
                elif left.find('-') >= 0:
                    idx = left.find('-')
                    base = left[0:idx]
                    quote = left[idx + 1:]
                    left = base
                    right = quote
            s = left + '/' + right
        else:
            s = self.strip_addr_suffix_upper(s)
            if s.endswith('-PERP'):
                s = s[0:len(s) - 5] + '/USDC'
            if (s.find('/') < 0) and (s.find('-') >= 0):
                idx = s.find('-')
                s = s[0:idx] + '/' + s[idx + 1:]
        return s

    def intent_seed_hex(self) -> str:
        # Same SEED used in ts-sdk composeHexPayload
        return 'e2ac4e5688d964270ad876d760c2ebb2d54fb26d93512c790049b6583730d06f'

    def serialize_string_hex(self, value: str) -> str:
        bin = self.encode(value)
        length = self.binary_length(bin)
        ulebHex = self.encode_uleb128_length(length)
        dataHex = self.binary_to_base16(bin)
        return ulebHex + dataHex

    def encode_uleb128_length(self, len: float) -> str:
        v = len
        uleb = ''
        while(v >= 0x80):
            low7 = v % 128
            byteVal = low7 + 0x80
            uleb += self.binary_to_base16(self.number_to_le(byteVal, 1))
            v = int(math.floor(v / 0x80))
        uleb += self.binary_to_base16(self.number_to_le(v, 1))
        return uleb

    def from_decimals(self, valueInt: float, decimals: float) -> float:
        if valueInt is None:
            return None
        if decimals is None:
            return valueInt
        return valueInt / math.pow(10, decimals)

    def apply_price_multiplier(self, price: float) -> float:
        multiplier = self.safe_number(self.options, 'priceMultiplier', 1)
        if price is None:
            return price
        if (multiplier is not None) and (multiplier != 1):
            return price * multiplier
        return price

    def parse_ticker_stats(self, response: dict, market: Market) -> Ticker:
        last = self.safe_number(response, 'current_price')
        high = self.safe_number(response, 'high_24h')
        low = self.safe_number(response, 'low_24h')
        percentage = self.safe_number(response, 'price_change_24h')
        rawQuoteVolume = self.safe_number(response, 'volume_24h')
        quoteVolume = 0
        if (rawQuoteVolume is not None) and (rawQuoteVolume > 0):
            quoteVolume = rawQuoteVolume
        baseVolume = 0
        if (quoteVolume > 0) and (last is not None) and (last > 0):
            baseVolume = quoteVolume / last
        infoMarket = market['info'] or {}
        quoteDecimals = self.safe_integer(infoMarket, 'quote_decimals')
        markInt = self.safe_integer(infoMarket, 'mark_price')
        oracleInt = self.safe_integer(infoMarket, 'oracle_price')
        markPrice = self.from_decimals(markInt, quoteDecimals)
        indexPrice = self.from_decimals(oracleInt, quoteDecimals)
        last = self.apply_price_multiplier(last)
        high = self.apply_price_multiplier(high)
        low = self.apply_price_multiplier(low)
        markPrice = self.apply_price_multiplier(markPrice)
        indexPrice = self.apply_price_multiplier(indexPrice)
        now = self.milliseconds()
        return self.safe_ticker({
            'symbol': market['symbol'],
            'timestamp': now,
            'datetime': self.iso8601(now),
            'high': high,
            'low': low,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': self.safe_number(response, 'price_24h_ago'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': percentage,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'markPrice': markPrice,
            'indexPrice': indexPrice,
            'info': response,
        }, market)

    async def compute2_4h_volumes_from_candles(self, market: Market) -> dict:
        try:
            since = self.milliseconds() - 24 * 60 * 60 * 1000
            candles = await self.fetch_ohlcv(market['symbol'], '1m', since, 1440)
            baseSum = 0
            quoteSum = 0
            infoMarket = market['info'] or {}
            baseDecimals = self.safe_integer(infoMarket, 'base_decimals')
            for i in range(0, len(candles)):
                volRaw = candles[i][5]
                close = candles[i][4]
                if volRaw is not None:
                    volBase: Any = volRaw
                    if baseDecimals is not None:
                        volBase = volRaw / math.pow(10, baseDecimals)
                    if (volBase is not None) and (volBase > 0):
                        baseSum += volBase
                        if (close is not None) and (close > 0):
                            quoteSum += volBase * close
            result: dict = {}
            if baseSum > 0:
                result['baseVolume'] = baseSum
            if quoteSum > 0:
                result['quoteVolume'] = quoteSum
            return result
        except Exception as e:
            # ignore fallback errors
            # eslint-disable-next-line no-unused-vars
            _ = e
            return {}

    def serialize_action_payload_hex(self, payload: dict) -> str:
        # Mirrors ts-sdk/src/utils/buildOrderPayload.ts
        out = self.serialize_string_hex(self.safe_string(payload, 'type'))
        if payload['type'] == 'leverage_assign':
            out += self.binary_to_base16(self.number_to_le(self.safe_integer(payload, 'leverage'), 8))
            out += self.serialize_string_hex(self.safe_string(payload, 'market_addr'))
        elif payload['type'] == 'order_cancel':
            cancels = payload['cancels'] or []
            # uleb128 length
            lenHex = self.encode_uleb128_length(len(cancels))
            out += lenHex
            for i in range(0, len(cancels)):
                out += self.serialize_string_hex(self.safe_string(cancels[i], 'sid'))
        elif payload['type'] == 'order_create':
            orders = payload['orders'] or []
            # uleb128 length
            lenHex = self.encode_uleb128_length(len(orders))
            out += lenHex
            for i in range(0, len(orders)):
                o = orders[i]
                out += self.serialize_string_hex(self.safe_string(o, 'side'))
                out += self.binary_to_base16(self.number_to_le(self.safe_integer(o, 'size'), 8))
                out += self.binary_to_base16(self.number_to_le(self.safe_integer(o, 'price'), 8))
                out += self.binary_to_base16(self.number_to_le(self.safe_integer(o, 'leverage'), 8))
                out += self.serialize_string_hex(self.safe_string(o, 'type'))
                out += self.serialize_string_hex(self.safe_string(o, 'market_addr'))
        else:
            raise NotSupported(self.id + ' unsupported payload type: ' + payload['type'])
        return out

    def build_message_hex(self, payloadHex: str, nonce: float) -> str:
        return self.intent_seed_hex() + payloadHex + self.binary_to_base16(self.number_to_le(nonce, 8))

    def sign_message_hex(self, messageHex: str) -> str:
        msgBin = self.base16_to_binary(messageHex)
        pkHex = self.secret[2:] if self.secret.startswith('0x') else self.secret
        secret = self.base16_to_binary(pkHex)
        sigB64 = self.eddsa(msgBin, secret, 'ed25519')
        sigHex = self.binary_to_base16(self.base64_to_binary(sigB64))
        return '0x' + sigHex

    def build_signed_intent(self, payload: dict, nonce: float) -> dict:
        payloadHex = self.serialize_action_payload_hex(payload)
        messageHex = self.build_message_hex(payloadHex, nonce)
        signature = self.sign_message_hex(messageHex)
        return {'payload': payload, 'nonce': nonce, 'signature': signature}

    def is_valid_signed_intent_params(self, params: dict, expectedType: str = None) -> bool:
        payload = self.safe_value(params, 'payload')
        payloadType = self.safe_string(payload, 'type')
        sig = self.safe_string(params, 'signature')
        hasNonce = ('nonce' in params)
        hasType = (payloadType is not None)
        typeOk = True if (expectedType is None) else (payloadType == expectedType)
        sigOk = (sig is not None) and (len(sig) > 2)
        return(payload is not None) and hasType and typeOk and sigOk and hasNonce

    def scale_order_fields(self, market: Market, side: OrderSide, amount: float, price: Num, type: OrderType, leverage: float) -> dict:
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.parse_to_int(amount * math.pow(10, baseDecimals)) if (baseDecimals is not None and amount is not None) else None
        priceInt = self.parse_to_int(price * math.pow(10, quoteDecimals)) if (quoteDecimals is not None and price is not None) else 0
        return {
            'market_addr': market['id'],
            'side': side,
            'size': sizeInt,
            'price': priceInt,
            'type': type,
            'leverage': leverage,
        }

    def parse_cancel_order_result(self, response: dict, requestedId: str, market: Market = None) -> Order:
        # Attempt to locate the canceled sid in outputs; fall back to requestedId
        id = requestedId
        output = self.safe_value(response, 'output')
        outputType = self.safe_string(output, 'type')
        if output and outputType == 'order_cancel':
            outputs = self.safe_value(output, 'outputs', [])
            if (outputs is not None) and (len(outputs) > 0):
                first = outputs[0]
                sid = self.safe_string(first, 'sid')
                if sid is not None:
                    id = sid
        ts = self.safe_integer(response, 'timestamp')
        timestamp = self.parse_to_int(ts * 1000) if (ts is not None) else None
        datetime = self.iso8601(timestamp)
        symbolOut = market['symbol'] if market else None
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': None,
            'status': 'canceled',
            'symbol': symbolOut,
            'type': None,
            'timeInForce': None,
            'postOnly': None,
            'side': None,
            'price': None,
            'stopPrice': None,
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'cost': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'average': None,
            'fee': None,
            'trades': [],
            'reduceOnly': None,
            'info': response,
        }, market)

    def parse_create_order_result(self, response: dict, payload: dict, market: Market, amount: float, price: Num, side: OrderSide, type: OrderType) -> Order:
        # Extract order sid from response.output or response.sid
        id = None
        output = self.safe_value(response, 'output')
        outputType = self.safe_string(output, 'type')
        if output and outputType == 'order_create':
            outputs = self.safe_value(output, 'outputs', [])
            if (outputs is not None) and (len(outputs) > 0):
                id = self.safe_string(outputs[0], 'sid')
        if id is None:
            id = self.safe_string(response, 'sid')
        ts = self.safe_integer(response, 'timestamp')
        timestamp = self.parse_to_int(ts * 1000) if (ts is not None) else None
        datetime = self.iso8601(timestamp)
        symbolOut = market['symbol'] if market else None
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': None,
            'status': 'open',
            'symbol': symbolOut,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'cost': None,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'average': None,
            'fee': None,
            'trades': [],
            'reduceOnly': None,
            'info': response,
        }, market)

    def describe(self) -> Any:
        return self.deep_extend(super(ekiden, self).describe(), {
            'id': 'ekiden',
            'name': 'Ekiden',
            'countries': [],
            'rateLimit': 50,
            'version': 'v1',
            'certified': False,
            'pro': False,
            'dex': True,
            'has': {
                'CORS': None,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchPositions': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'sandbox': True,
                'setLeverage': True,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
            },
            'hostname': 'ekiden.fi',
            'urls': {
                'logo': 'https://raw.githubusercontent.com/ekidenfi/ekiden-docs/refs/heads/main/logo/light.svg',
                'api': {
                    'public': 'https://api.staging.ekiden.fi',
                    'private': 'https://api.staging.ekiden.fi',
                },
                'test': {
                    'public': 'https://api.staging.ekiden.fi',
                    'private': 'https://api.staging.ekiden.fi',
                },
                'www': 'https://ekiden.fi',
                'doc': [
                    'https://docs.ekiden.fi',
                ],
            },
            'precisionMode': DECIMAL_PLACES,
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'market/candles': 1,
                            'market/candles/stats/{market_addr}': 1,
                            'market/market_info': 1,
                            'market/fills': 1,
                            'market/orders': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'user/orders': 1,
                            'user/portfolio': 1,
                            'user/positions': 1,
                        },
                        'post': {
                            'user/intent': 1,
                            'user/intent/commit': 1,
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': self.parse_number('0.001'),
                    'maker': self.parse_number('0.001'),
                },
            },
            'options': {
                'defaultType': 'swap',
                'sandboxMode': True,
                'priceMultiplier': 1,
                'createMarketBuyOrderRequiresPrice': True,
            },
            'commonCurrencies': {
            },
        })

    def sign(self, path, api=[], method='GET', params={}, headers=None, body=None):
        version = api[0]
        scope = api[1]  # 'public' | 'private'
        fullPath = '/api/' + version + '/' + self.implode_params(path, params)
        url = self.urls['api'][scope] + fullPath
        params = self.omit(params, self.extract_params(path))
        if method == 'GET':
            query = self.urlencode(params)
            if len(query):
                url += '?' + query
        else:
            if params:
                body = self.json(params)
        headers = {'Content-Type': 'application/json'}
        if scope == 'private' and self.apiKey:
            headers['Authorization'] = 'Bearer ' + self.apiKey
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def fetch_markets(self, params={}) -> List[Market]:
        response = await self.v1PublicGetMarketMarketInfo(params)
        # response: array of MarketResponse
        result: List[Market] = []
        for i in range(0, len(response)):
            market = response[i]
            id = self.safe_string(market, 'addr')
            rawSymbol = self.safe_string(market, 'symbol')
            normalized = self.normalize_symbol(rawSymbol) if (rawSymbol is not None) else None
            baseId = self.safe_string(market, 'base_addr')
            quoteId = self.safe_string(market, 'quote_addr')
            # derive human-readable currency codes from normalized symbol
            baseCode = None
            quoteCode = None
            if normalized:
                parts = normalized.split('/')
                if len(parts) > 1:
                    baseCode = parts[0]
                    quoteCode = parts[1].split(':')[0]
            baseDecimals = self.safe_integer(market, 'base_decimals')
            quoteDecimals = self.safe_integer(market, 'quote_decimals')
            linear = True
            type = 'future'
            settle = quoteCode
            settleId = quoteId
            active = True
            precision = {'amount': baseDecimals, 'price': quoteDecimals}
            symbol = normalized
            # if baseCode and quoteCode and settle:
            #     symbol = baseCode + '/' + quoteCode + ':' + settle
            # }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': baseCode,
                'quote': quoteCode,
                'baseId': baseId,
                'quoteId': quoteId,
                'type': type,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': True,
                'option': False,
                'contract': True,
                'linear': linear,
                'inverse': not linear,
                'settle': settle,
                'settleId': settleId,
                'contractSize': 1,
                'active': active,
                'precision': precision,
                'limits': {},
                'info': market,
            })
        return result

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        id = self.safe_string(trade, 'sid')
        side = self.safe_string_lower(trade, 'side')
        ts = self.safe_integer(trade, 'timestamp')
        timestamp = self.parse_to_int(ts) if (ts is not None) else None
        marketId = self.safe_string(trade, 'market_addr')
        market = market or self.safe_market(marketId)
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.safe_integer(trade, 'size')
        priceInt = self.safe_integer(trade, 'price')
        amount = self.from_decimals(sizeInt, baseDecimals)
        price = self.from_decimals(priceInt, quoteDecimals)
        datetime = self.iso8601(timestamp) if (timestamp is not None) else None
        if amount is not None:
            amount = abs(amount)
        cost = (amount * price) if (amount is not None and price is not None) else None
        return self.safe_trade({
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': market['symbol'] if market else None,
            'side': side,
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
            'info': trade,
        }, market)

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {
            'market_addr': market['id'],
        }
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PublicGetMarketFills(self.extend(request, params))
        # response: array of FillResponse
        trades = self.parse_trades(response, market, since, limit)
        return trades

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {'market_addr': market['id']}
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PublicGetMarketOrders(self.extend(request, params))
        # response: array of OrderResponse with side/price/size ints
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        bidsMap: dict = {}
        asksMap: dict = {}
        for i in range(0, len(response)):
            o = response[i]
            side = self.safe_string_lower(o, 'side')
            priceInt = self.safe_integer(o, 'price')
            sizeInt = self.safe_integer(o, 'size')
            if priceInt is None or sizeInt is None:
                continue
            key = str(priceInt)
            sizeFloat = self.from_decimals(abs(sizeInt), baseDecimals)
            if sizeFloat is None:
                continue
            if side == 'buy':
                prev = self.safe_number(bidsMap, key, 0)
                bidsMap[key] = self.sum(prev, sizeFloat)
            elif side == 'sell':
                prev = self.safe_number(asksMap, key, 0)
                asksMap[key] = self.sum(prev, sizeFloat)
        bids = []
        asks = []
        bidKeys = list(bidsMap.keys())
        for i in range(0, len(bidKeys)):
            k = bidKeys[i]
            pInt = self.parse_to_numeric(k)
            pFloat = self.from_decimals(pInt, quoteDecimals)
            pFloat = self.apply_price_multiplier(pFloat)
            bids.append([pFloat, bidsMap[k]])
        askKeys = list(asksMap.keys())
        for i in range(0, len(askKeys)):
            k = askKeys[i]
            pInt = self.parse_to_numeric(k)
            pFloat = self.from_decimals(pInt, quoteDecimals)
            pFloat = self.apply_price_multiplier(pFloat)
            asks.append([pFloat, asksMap[k]])
        orderbook = {'bids': bids, 'asks': asks}
        result = self.parse_order_book(orderbook, symbol)
        if limit is not None:
            result['bids'] = result['bids'][0:limit]
            result['asks'] = result['asks'][0:limit]
        return result

    async def fetch_positions(self, symbols: Strings = None, params={}) -> List[Position]:
        await self.load_markets()
        self.check_required_credentials(False)
        symbols = self.market_symbols(symbols)
        response = await self.v1PrivateGetUserPortfolio(params)
        positions = self.safe_list(response, 'positions', [])
        result: List[Position] = []
        for i in range(0, len(positions)):
            pos = positions[i]
            marketId = self.safe_string(pos, 'market_addr')
            if marketId is None:
                continue  # cannot map to symbol
            market = self.safe_market(marketId)
            unified = self.parse_position(pos, market)
            if symbols is None or (symbols.find(unified['symbol']) >= 0):
                result.append(unified)
        return result

    def parse_position(self, position: dict, market: Market = None) -> Position:
        marketId = self.safe_string(position, 'market_addr')
        market = self.safe_market(marketId, market)
        infoMarket = (market['info'] or {}) if market else {}
        baseDecimals = self.safe_integer(infoMarket, 'base_decimals')
        quoteDecimals = self.safe_integer(infoMarket, 'quote_decimals')
        sizeInt = self.safe_integer(position, 'size')
        priceInt = self.safe_integer(position, 'price')
        marginInt = self.safe_integer(position, 'margin')
        tsSec = self.safe_integer(position, 'timestamp')
        timestamp = (tsSec * 1000) if (tsSec is not None) else None
        contracts = self.from_decimals(abs(sizeInt), baseDecimals)
        entryPrice = self.from_decimals(priceInt, quoteDecimals)
        entryPrice = self.apply_price_multiplier(entryPrice)
        markPx = None
        markInt = self.safe_integer(infoMarket, 'mark_price')
        if markInt is not None:
            markPx = self.from_decimals(markInt, quoteDecimals)
            markPx = self.apply_price_multiplier(markPx)
        side = None
        if sizeInt is not None:
            if sizeInt > 0:
                side = 'long'
            elif sizeInt < 0:
                side = 'short'
        notional = (contracts * markPx) if (contracts is not None and markPx is not None) else None
        collateral = self.from_decimals(marginInt, quoteDecimals) if (marginInt is not None) else None
        unrealizedPnl = None
        if markPx is not None and entryPrice is not None and sizeInt is not None:
            unrealizedPnl = (markPx - entryPrice) * (sizeInt >= 1 if 0 else -1) * abs(contracts)
        leverage = None
        if (notional is not None) and (collateral is not None) and (collateral > 0):
            leverage = notional / collateral
        return self.safe_position({
            'info': position,
            'id': self.safe_string(position, 'sid'),
            'symbol': market['symbol'] if market else None,
            'notional': notional,
            'marginMode': 'cross',
            'liquidationPrice': None,
            'entryPrice': entryPrice,
            'unrealizedPnl': unrealizedPnl,
            'realizedPnl': None,
            'percentage': None,
            'contracts': contracts,
            'contractSize': None,
            'markPrice': markPx,
            'lastPrice': None,
            'side': side,
            'hedged': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp) if (timestamp is not None) else None,
            'lastUpdateTimestamp': timestamp,
            'maintenanceMargin': None,
            'maintenanceMarginPercentage': None,
            'collateral': collateral,
            'initialMargin': collateral,
            'initialMarginPercentage': None,
            'leverage': leverage,
            'marginRatio': None,
            'stopLossPrice': None,
            'takeProfitPrice': None,
        })

    async def fetch_balance(self, params={}) -> Balances:
        # Derive balances from user portfolio endpoint; assumes a single quote asset vault(e.g., USDC)
        self.check_required_credentials()
        response = await self.v1PrivateGetUserPortfolio(params)
        # response: PortfolioResponse {vault_balances: [{asset_addr, balance}], summary: {total_margin_used}}
        vaults = self.safe_value(response, 'vault_balances', [])
        summary = self.safe_value(response, 'summary', {})
        # Try to detect decimals from markets using the first vault asset
        await self.load_markets()
        decimals = None
        code: str = 'USDC'
        if len(vaults) > 0:
            assetAddr = self.safe_string(vaults[0], 'asset_addr')
            # find any market where quoteId == assetAddr
            marketIds = list(self.markets_by_id or {}.keys())
            for i in range(0, len(marketIds)):
                m: Any = self.markets_by_id[marketIds[i]]
                # markets_by_id can map an id to an array of market dicts; use the first
                if isinstance(m, list) and len(m) > 0:
                    m = m[0]
                info = (m['info'] or {}) if m else {}
                quoteId = self.safe_string(info, 'quote_addr')
                if quoteId == assetAddr:
                    decimals = self.safe_integer(info, 'quote_decimals')
                    # Best-effort code detection: try to parse from symbol suffix(e.g., BTC/USDC)
                    sym = self.safe_string(m, 'symbol')
                    if sym:
                        parts = sym.split('/')
                        if len(parts) > 1:
                            code = parts[1].split(':')[0]
                    break
        totalRaw = self.safe_integer(vaults[0] or {}, 'balance')
        usedRaw = self.safe_integer(summary, 'total_margin_used')
        total = None
        if totalRaw is not None:
            total = (totalRaw / math.pow(10, decimals)) if (decimals is not None) else totalRaw
        used = 0
        if usedRaw is not None:
            used = (usedRaw / math.pow(10, decimals)) if (decimals is not None) else usedRaw
        # clamp to avoid negative free due to inconsistent margin usage values
        if total is not None:
            if used is None:
                used = 0
            if used > total:
                used = total
        free = (total - used) if (total is not None and used is not None) else None
        if free is not None and free < 0:
            free = 0
        result: dict = {'info': response}
        result[code] = {
            'free': free,
            'used': used,
            'total': total,
        }
        # For linear perps, allow shorting without base inventory by exposing a synthetic base capacity
        # Compute per-market base capacity from quote free and mark price with max leverage
        try:
            await self.load_markets()
            marketIds = list(self.markets_by_id or {}.keys())
            for i in range(0, len(marketIds)):
                m: Any = self.markets_by_id[marketIds[i]]
                if isinstance(m, list) and len(m) > 0:
                    m = m[0]
                info = (m['info'] or {}) if m else {}
                baseCode = self.safe_string(m, 'base')
                quoteDecimals2 = self.safe_integer(info, 'quote_decimals')
                markInt2 = self.safe_integer(info, 'mark_price')
                leverageMax = self.safe_number(info, 'max_leverage', 1)
                if baseCode and (result[baseCode] is None):
                    markPx = self.from_decimals(markInt2, quoteDecimals2)
                    markPx = self.apply_price_multiplier(markPx)
                    if (free is not None) and (free > 0) and (markPx is not None) and (markPx > 0):
                        baseCapacity = (free * leverageMax) / markPx
                        result[baseCode] = {
                            'free': baseCapacity,
                            'used': 0,
                            'total': baseCapacity,
                        }
                    else:
                        # if no mark price or no quote free, still expose zero to avoid KeyError
                        result[baseCode] = {'free': 0, 'used': 0, 'total': 0}
        except Exception as e:
            # ignore synthetic capacity errors
            # eslint-disable-next-line no-unused-vars
            _ = e
        return self.safe_balance(result)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        ts = self.safe_integer(ohlcv, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        open = self.safe_number(ohlcv, 'open')
        high = self.safe_number(ohlcv, 'high')
        low = self.safe_number(ohlcv, 'low')
        close = self.safe_number(ohlcv, 'close')
        volume = self.safe_number(ohlcv, 'volume')
        return [timestamp, open, high, low, close, volume]

    async def fetch_ohlcv(self, symbol: str, timeframe='1h', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {
            'market_addr': market['id'],
            'timeframe': timeframe,
        }
        if since is not None:
            request['start_time'] = self.parse_to_int(since / 1000)
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PublicGetMarketCandles(self.extend(request, params))
        # response is array of {timestamp, open, high, low, close, volume, count}
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        await self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        response = await self.v1PublicGetMarketCandlesStatsMarketAddr(self.extend({'market_addr': market['id']}, params))
        ticker = self.parse_ticker_stats(response, market)
        # Fallback: when 24h volumes are missing/zero from stats, compute from candles
        missingQuote = (ticker['quoteVolume'] is None) or (ticker['quoteVolume'] <= 0)
        missingBase = (ticker['baseVolume'] is None) or (ticker['baseVolume'] <= 0)
        if missingQuote and missingBase:
            fromCandles = await self.compute2_4h_volumes_from_candles(market)
            if (fromCandles['baseVolume'] is not None) and (fromCandles['baseVolume'] > 0):
                ticker['baseVolume'] = fromCandles['baseVolume']
            if (fromCandles['quoteVolume'] is not None) and (fromCandles['quoteVolume'] > 0):
                ticker['quoteVolume'] = fromCandles['quoteVolume']
            elif (ticker['baseVolume'] is not None) and (ticker['baseVolume'] > 0):
                last = ticker['last']
                if (last is not None) and (last > 0):
                    ticker['quoteVolume'] = ticker['baseVolume'] * last
        return ticker

    async def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        """
        fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        :param str[]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of tickers indexed by market symbol
        """
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        symbolsArray: Any = symbols
        if symbolsArray is None:
            symbolsArray = self.symbols
        result: dict = {}
        for i in range(0, len(symbolsArray)):
            symbol = symbolsArray[i]
            market = self.market(self.normalize_symbol(symbol))
            response = await self.v1PublicGetMarketCandlesStatsMarketAddr(self.extend({'market_addr': market['id']}, params))
            ticker = self.parse_ticker_stats(response, market)
            missingQuote = (ticker['quoteVolume'] is None) or (ticker['quoteVolume'] <= 0)
            missingBase = (ticker['baseVolume'] is None) or (ticker['baseVolume'] <= 0)
            if missingQuote and missingBase:
                fromCandles = await self.compute2_4h_volumes_from_candles(market)
                if (fromCandles['baseVolume'] is not None) and (fromCandles['baseVolume'] > 0):
                    ticker['baseVolume'] = fromCandles['baseVolume']
                if (fromCandles['quoteVolume'] is not None) and (fromCandles['quoteVolume'] > 0):
                    ticker['quoteVolume'] = fromCandles['quoteVolume']
                elif (ticker['baseVolume'] is not None) and (ticker['baseVolume'] > 0):
                    last = ticker['last']
                    if (last is not None) and (last > 0):
                        ticker['quoteVolume'] = ticker['baseVolume'] * last
            result[market['symbol']] = ticker
        return result

    def parse_order(self, order: dict, market: Market = None) -> Order:
        id = self.safe_string(order, 'sid')
        statusRaw = self.safe_string(order, 'status')
        side = self.safe_string_lower(order, 'side')
        type = self.safe_string_lower(order, 'type')
        ts = self.safe_integer(order, 'timestamp')
        timestamp = self.parse_to_int(ts) if (ts is not None) else None
        marketId = self.safe_string(order, 'market_addr')
        market = market or self.safe_market(marketId)
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.safe_integer(order, 'size')
        priceInt = self.safe_integer(order, 'price')
        amount = self.from_decimals(sizeInt, baseDecimals)
        price = self.from_decimals(priceInt, quoteDecimals)
        if amount is not None:
            amount = abs(amount)
        status = None
        # map to ccxt statuses
        if statusRaw == 'placed' or statusRaw == 'created' or statusRaw == 'partial_filled':
            status = 'open'
        elif statusRaw == 'filled':
            status = 'closed'
        elif statusRaw == 'cancelled' or statusRaw == 'rejected':
            status = 'canceled'
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': market['symbol'] if market else None,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'cost': None,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'fee': None,
            'trades': None,
            'info': order,
        }, market)

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        request: dict = {}
        if market:
            request['market_addr'] = market['id']
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PrivateGetUserOrders(self.extend(request, params))
        parsed = self.parse_orders(response, market)
        return self.filter_by_array(parsed, 'status', ['open'], False)

    async def fetch_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        request: dict = {}
        if market:
            request['market_addr'] = market['id']
        if limit is not None:
            request['per_page'] = limit
        response = await self.v1PrivateGetUserOrders(self.extend(request, params))
        parsed = self.parse_orders(response, market)
        return self.filter_by_array(parsed, 'status', ['closed', 'canceled'], False)

    async def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        self.check_required_credentials(False)
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol to be specified')
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {'market_addr': market['id'], 'per_page': 100}
        response = await self.v1PrivateGetUserOrders(self.extend(request, params))
        for i in range(0, len(response)):
            item = response[i]
            if self.safe_string(item, 'sid') == id:
                return self.parse_order(item, market)
        raise OrderNotFound(self.id + ' fetchOrder() could not find order id ' + id)

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        # Ekiden requires signed intents over /api/v1/user/intent(Ed25519, Aptos-style BCS payload + nonce + seed)
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol))
        hasPayload = self.is_valid_signed_intent_params(params, 'order_create')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = None
            if commitProvided:
                responseProvided = await self.v1PrivatePostUserIntentCommit(request)
            else:
                responseProvided = await self.v1PrivatePostUserIntent(request)
            return self.safe_order({'id': None, 'symbol': market['symbol'], 'info': responseProvided})
        if not self.secret:
            raise NotSupported(self.id + ' createOrder() requires either params {payload, signature, nonce} or exchange.secret to sign the intent')
        leverage = self.safe_integer(params, 'leverage', 1)
        commitFlag = self.safe_bool(params, 'commit', True)
        postOnlyParam: Bool = self.safe_bool(params, 'postOnly')
        reduceOnlyParam: Bool = self.safe_bool(params, 'reduceOnly')
        params = self.omit(params, ['postOnly', 'reduceOnly'])
        # Handle market buy semantics: allow quote-cost via params.cost, enforce price presence
        adjustedAmount = amount
        adjustedPrice: Any = price
        if (type == 'market') and (side == 'buy'):
            cost = self.safe_number(params, 'cost')
            if cost is not None:
                if adjustedPrice is None:
                    raise InvalidOrder(self.id + ' createOrder() requires price when cost is provided for market buy orders')
                adjustedAmount = cost / adjustedPrice
                params = self.omit(params, 'cost')
            else:
                requiresPrice = self.safe_bool(self.options, 'createMarketBuyOrderRequiresPrice', True)
                if requiresPrice and (adjustedPrice is None):
                    raise InvalidOrder(self.id + ' createOrder() requires the price argument for market buy orders to calculate notional for validation')
        # Honor reduceOnly: ensure order reduces existing position and does not exceed position size
        if reduceOnlyParam:
            try:
                allPositions = await self.fetch_positions(None, {})
                # find position for self market
                posForMarket: Position = None
                for i in range(0, len(allPositions)):
                    p = allPositions[i]
                    if p['symbol'] == market['symbol']:
                        posForMarket = p
                        break
                posContracts = self.safe_number(posForMarket, 'contracts') if posForMarket else 0
                posSide = self.safe_string(posForMarket, 'side') if posForMarket else None
                absContracts = abs(posContracts) if (posContracts is not None) else 0
                if not posForMarket or not posSide or (absContracts == 0):
                    raise InvalidOrder(self.id + ' createOrder() reduceOnly is set but no position to reduce for ' + market['symbol'])
                if (posSide == 'long' and side != 'sell') or (posSide == 'short' and side != 'buy'):
                    raise InvalidOrder(self.id + ' createOrder() reduceOnly order side must reduce the current position side')
                # clamp amount not to exceed current position size
                if (adjustedAmount is not None) and (absContracts is not None):
                    adjustedAmount = min(adjustedAmount, absContracts)
                    if adjustedAmount <= 0:
                        raise InvalidOrder(self.id + ' createOrder() reduceOnly adjusted amount is zero')
            except Exception as e:
                if isinstance(e, InvalidOrder):
                    raise e
                # if positions endpoint fails, fallback to proceed(cannot guarantee reduce-only without server support)
        # Honor postOnly: ensure limit order does not cross the spread
        if postOnlyParam:
            isLimit = (type == 'limit')
            if not isLimit:
                raise InvalidOrder(self.id + ' createOrder() postOnly is only supported for limit orders')
            if adjustedPrice is None:
                raise InvalidOrder(self.id + ' createOrder() postOnly requires a price')
            try:
                ob = await self.fetch_order_book(market['symbol'], 1)
                bestAsk = ob['asks'][0][0] if (ob['asks'] and len(ob['asks']) > 0) else None
                bestBid = ob['bids'][0][0] if (ob['bids'] and len(ob['bids']) > 0) else None
                if side == 'buy' and (bestAsk is not None) and (adjustedPrice >= bestAsk):
                    raise InvalidOrder(self.id + ' createOrder() postOnly buy price would cross the best ask')
                if side == 'sell' and (bestBid is not None) and (adjustedPrice <= bestBid):
                    raise InvalidOrder(self.id + ' createOrder() postOnly sell price would cross the best bid')
            except Exception as e:
                if isinstance(e, InvalidOrder):
                    raise e
                # if orderbook fetch fails, proceed(cannot guarantee post-only)
        order = self.scale_order_fields(market, side, adjustedAmount, adjustedPrice, type, leverage)
        payload: dict = {'type': 'order_create', 'orders': [order]}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned = None
        if commitFlag:
            responseSigned = await self.v1PrivatePostUserIntentCommit(request)
        else:
            responseSigned = await self.v1PrivatePostUserIntent(request)
        # If committed, try to resolve the final order from user/orders by seq
        if commitFlag:
            seq = self.safe_integer(responseSigned, 'seq')
            if seq is not None:
                try:
                    list = await self.v1PrivateGetUserOrders({'market_addr': market['id'], 'per_page': 50})
                    for i in range(0, len(list)):
                        it = list[i]
                        if self.safe_integer(it, 'seq') == seq:
                            return self.parse_order(it, market)
                except Exception as e:
                    # ignore and fallback below
                    # eslint-disable-next-line no-unused-vars
                    _ = e  # no-op to satisfy transpilers
        return self.parse_create_order_result(responseSigned, payload, market, amount, price, side, type)

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        hasPayload = self.is_valid_signed_intent_params(params, 'order_cancel')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = None
            if commitProvided:
                responseProvided = await self.v1PrivatePostUserIntentCommit(request)
            else:
                responseProvided = await self.v1PrivatePostUserIntent(request)
            return self.parse_cancel_order_result(responseProvided, id, market)
        if not self.secret:
            raise NotSupported(self.id + ' cancelOrder() requires either params {payload, signature, nonce} or exchange.secret to sign the intent')
        commitFlag = self.safe_bool(params, 'commit', True)
        # Build cancel payload for a single sid(id)
        payload: dict = {'type': 'order_cancel', 'cancels': [{'sid': id}]}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned2 = None
        if commitFlag:
            responseSigned2 = await self.v1PrivatePostUserIntentCommit(request)
        else:
            responseSigned2 = await self.v1PrivatePostUserIntent(request)
        return self.parse_cancel_order_result(responseSigned2, id, market)

    async def set_leverage(self, leverage: float, symbol: Str = None, params={}):
        await self.load_markets()
        if symbol is None:
            raise ArgumentsRequired(self.id + ' setLeverage() requires a symbol argument')
        market = self.market(self.normalize_symbol(symbol))
        hasPayload = self.is_valid_signed_intent_params(params, 'leverage_assign')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = None
            if commitProvided:
                responseProvided = await self.v1PrivatePostUserIntentCommit(request)
            else:
                responseProvided = await self.v1PrivatePostUserIntent(request)
            return {'info': responseProvided, 'symbol': market['symbol']}
        if not self.secret:
            raise NotSupported(self.id + ' setLeverage() requires either params {payload, signature, nonce} or exchange.secret to sign the intent')
        commitFlag = self.safe_bool(params, 'commit', True)
        payload: dict = {'type': 'leverage_assign', 'leverage': leverage, 'market_addr': market['id']}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned = None
        if commitFlag:
            responseSigned = await self.v1PrivatePostUserIntentCommit(request)
        else:
            responseSigned = await self.v1PrivatePostUserIntent(request)
        return {'info': responseSigned, 'symbol': market['symbol']}
