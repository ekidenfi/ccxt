# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.abstract.ekiden import ImplicitAPI
import math
from ccxt.base.types import Any, Balances, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Str, Ticker, Trade
from typing import List
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.decimal_to_precision import DECIMAL_PLACES


class ekiden(Exchange, ImplicitAPI):

    def strip_addr_suffix_upper(self, value: str) -> str:
        up = value.upper()
        tag = '-0X'
        idx = up.find(tag)
        if idx >= 0:
            hexPart = up[idx + len(tag):]
            if hexPart and len(hexPart) > 0:
                isHex = True
                for j in range(0, len(hexPart)):
                    ch = hexPart[j]
                    isDigit = (ch >= '0') and (ch <= '9')
                    isAF = (ch >= 'A') and (ch <= 'F')
                    if not isDigit and not isAF:
                        isHex = False
                        break
                if isHex:
                    return value[0:idx]
        return value

    def normalize_symbol(self, symbol: str) -> str:
        s = symbol.upper()
        if s.find('/') >= 0:
            parts = s.split('/')
            leftRaw = parts[0]
            rightRaw = parts[1]
            left = self.strip_addr_suffix_upper(leftRaw)
            right = rightRaw
            if right == 'NONE':
                if left.endswith('-PERP'):
                    left = left[0:len(left) - 5]
                    right = 'USDC'
                elif left.find('-') >= 0:
                    idx = left.find('-')
                    base = left[0:idx]
                    quote = left[idx + 1:]
                    left = base
                    right = quote
            s = left + '/' + right
        else:
            s = self.strip_addr_suffix_upper(s)
            if s.endswith('-PERP'):
                s = s[0:len(s) - 5] + '/USDC'
            if (s.find('/') < 0) and (s.find('-') >= 0):
                idx = s.find('-')
                s = s[0:idx] + '/' + s[idx + 1:]
        return s

    def intent_seed_hex(self) -> str:
        # Same SEED used in ts-sdk composeHexPayload
        return 'e2ac4e5688d964270ad876d760c2ebb2d54fb26d93512c790049b6583730d06f'

    def serialize_string_hex(self, value: str) -> str:
        bin = self.encode(value)
        # Build ULEB128 length manually using numberToLE for cross-language compatibility
        length = self.binary_length(bin)
        v = length
        ulebHex = ''
        while(v >= 0x80):
            low7 = v % 128
            byteVal = low7 + 0x80
            ulebHex += self.binary_to_base16(self.number_to_le(byteVal, 1))
            v = int(math.floor(v / 0x80))
        ulebHex += self.binary_to_base16(self.number_to_le(v, 1))
        dataHex = self.binary_to_base16(bin)
        return ulebHex + dataHex

    def encode_uleb128_length(self, len: float) -> str:
        v = len
        uleb = ''
        while(v >= 0x80):
            low7 = v % 128
            byteVal = low7 + 0x80
            uleb += self.binary_to_base16(self.number_to_le(byteVal, 1))
            v = int(math.floor(v / 0x80))
        uleb += self.binary_to_base16(self.number_to_le(v, 1))
        return uleb

    def serialize_action_payload_hex(self, payload: dict) -> str:
        # Mirrors ts-sdk/src/utils/buildOrderPayload.ts
        out = self.serialize_string_hex(self.safe_string(payload, 'type'))
        if payload['type'] == 'leverage_assign':
            out += self.binary_to_base16(self.number_to_le(self.safe_integer(payload, 'leverage'), 8))
            out += self.serialize_string_hex(self.safe_string(payload, 'market_addr'))
        elif payload['type'] == 'order_cancel':
            cancels = payload['cancels'] or []
            # uleb128 length
            lenHex = self.encode_uleb128_length(len(cancels))
            out += lenHex
            for i in range(0, len(cancels)):
                out += self.serialize_string_hex(self.safe_string(cancels[i], 'sid'))
        elif payload['type'] == 'order_create':
            orders = payload['orders'] or []
            # uleb128 length
            lenHex = self.encode_uleb128_length(len(orders))
            out += lenHex
            for i in range(0, len(orders)):
                o = orders[i]
                out += self.serialize_string_hex(self.safe_string(o, 'side'))
                out += self.binary_to_base16(self.number_to_le(self.safe_integer(o, 'size'), 8))
                out += self.binary_to_base16(self.number_to_le(self.safe_integer(o, 'price'), 8))
                out += self.binary_to_base16(self.number_to_le(self.safe_integer(o, 'leverage'), 8))
                out += self.serialize_string_hex(self.safe_string(o, 'type'))
                out += self.serialize_string_hex(self.safe_string(o, 'market_addr'))
        else:
            raise NotSupported(self.id + ' unsupported payload type: ' + payload['type'])
        return out

    def build_message_hex(self, payloadHex: str, nonce: float) -> str:
        return self.intent_seed_hex() + payloadHex + self.binary_to_base16(self.number_to_le(nonce, 8))

    def sign_message_hex(self, messageHex: str) -> str:
        msgBin = self.base16_to_binary(messageHex)
        pkHex = self.secret[2:] if self.secret.startswith('0x') else self.secret
        secret = self.base16_to_binary(pkHex)
        sigB64 = self.eddsa(msgBin, secret, 'ed25519')
        sigHex = self.binary_to_base16(self.base64_to_binary(sigB64))
        return '0x' + sigHex

    def build_signed_intent(self, payload: dict, nonce: float) -> dict:
        payloadHex = self.serialize_action_payload_hex(payload)
        messageHex = self.build_message_hex(payloadHex, nonce)
        signature = self.sign_message_hex(messageHex)
        return {'payload': payload, 'nonce': nonce, 'signature': signature}

    def is_valid_signed_intent_params(self, params: dict, expectedType: str = None) -> bool:
        payload = self.safe_value(params, 'payload')
        payloadType = self.safe_string(payload, 'type')
        sig = self.safe_string(params, 'signature')
        hasNonce = ('nonce' in params)
        hasType = (payloadType is not None)
        typeOk = True if (expectedType is None) else (payloadType == expectedType)
        sigOk = (sig is not None) and (len(sig) > 2)
        return(payload is not None) and hasType and typeOk and sigOk and hasNonce

    def scale_order_fields(self, market: Market, side: OrderSide, amount: float, price: Num, type: OrderType, leverage: float) -> dict:
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.parse_to_int(amount * math.pow(10, baseDecimals)) if (baseDecimals is not None and amount is not None) else None
        priceInt = self.parse_to_int(price * math.pow(10, quoteDecimals)) if (quoteDecimals is not None and price is not None) else 0
        return {
            'market_addr': market['id'],
            'side': side,
            'size': sizeInt,
            'price': priceInt,
            'type': type,
            'leverage': leverage,
        }

    def parse_cancel_order_result(self, response: dict, requestedId: str, market: Market = None) -> Order:
        # Attempt to locate the canceled sid in outputs; fall back to requestedId
        id = requestedId
        output = self.safe_value(response, 'output')
        outputType = self.safe_string(output, 'type')
        if output and outputType == 'order_cancel':
            outputs = self.safe_value(output, 'outputs', [])
            if (outputs is not None) and (len(outputs) > 0):
                first = outputs[0]
                sid = self.safe_string(first, 'sid')
                if sid is not None:
                    id = sid
        ts = self.safe_integer(response, 'timestamp')
        timestamp = self.parse_to_int(ts) if (ts is not None) else None
        datetime = self.iso8601(timestamp)
        symbolOut = market['symbol'] if market else None
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': None,
            'status': 'canceled',
            'symbol': symbolOut,
            'type': None,
            'timeInForce': None,
            'postOnly': None,
            'side': None,
            'price': None,
            'stopPrice': None,
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'cost': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'average': None,
            'fee': None,
            'trades': [],
            'reduceOnly': None,
            'info': response,
        }, market)

    def parse_create_order_result(self, response: dict, payload: dict, market: Market, amount: float, price: Num, side: OrderSide, type: OrderType) -> Order:
        # Extract order sid from response.output or response.sid
        id = None
        output = self.safe_value(response, 'output')
        outputType = self.safe_string(output, 'type')
        if output and outputType == 'order_create':
            outputs = self.safe_value(output, 'outputs', [])
            if (outputs is not None) and (len(outputs) > 0):
                id = self.safe_string(outputs[0], 'sid')
        if id is None:
            id = self.safe_string(response, 'sid')
        ts = self.safe_integer(response, 'timestamp')
        timestamp = self.parse_to_int(ts) if (ts is not None) else None
        datetime = self.iso8601(timestamp)
        symbolOut = market['symbol'] if market else None
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': None,
            'status': 'open',
            'symbol': symbolOut,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'cost': None,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'average': None,
            'fee': None,
            'trades': [],
            'reduceOnly': None,
            'info': response,
        }, market)

    def describe(self) -> Any:
        return self.deep_extend(super(ekiden, self).describe(), {
            'id': 'ekiden',
            'name': 'Ekiden',
            'countries': [],
            'rateLimit': 50,
            'version': 'v1',
            'certified': False,
            'pro': False,
            'dex': True,
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': True,
                'future': True,
                'option': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchPositions': False,
                'fetchTicker': True,
                'fetchTickers': False,
                'fetchTrades': True,
                'sandbox': True,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
            },
            'hostname': 'ekiden.fi',
            'urls': {
                'logo': 'https://raw.githubusercontent.com/ekidenfi/ekiden-docs/refs/heads/main/logo/light.svg',
                'api': {
                    'public': 'https://api.staging.ekiden.fi',
                    'private': 'https://api.staging.ekiden.fi',
                },
                'test': {
                    'public': 'https://api.staging.ekiden.fi',
                    'private': 'https://api.staging.ekiden.fi',
                },
                'www': 'https://ekiden.fi',
                'doc': [
                    'https://docs.ekiden.fi',
                ],
            },
            'precisionMode': DECIMAL_PLACES,
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'market/candles': 1,
                            'market/candles/stats/{market_addr}': 1,
                            'market/market_info': 1,
                            'market/fills': 1,
                            'market/orders': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'user/orders': 1,
                        },
                        'post': {
                            'user/intent': 1,
                            'user/intent/commit': 1,
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': self.parse_number('0.001'),
                    'maker': self.parse_number('0.001'),
                },
            },
            'options': {
                'sandboxMode': True,
            },
            'commonCurrencies': {
            },
            'spot': {
                'extends': 'default',
            },
            'future': {
                'linear': {
                    'extends': 'forPerps',
                },
                'inverse': {
                    'extends': 'forPerps',
                },
            },
        })

    def sign(self, path, api=[], method='GET', params={}, headers=None, body=None):
        version = api[0]
        scope = api[1]  # 'public' | 'private'
        fullPath = '/api/' + version + '/' + self.implode_params(path, params)
        url = self.urls['api'][scope] + fullPath
        params = self.omit(params, self.extract_params(path))
        if method == 'GET':
            query = self.urlencode(params)
            if len(query):
                url += '?' + query
        else:
            if params:
                body = self.json(params)
        headers = {'Content-Type': 'application/json'}
        if scope == 'private' and self.apiKey:
            headers['Authorization'] = 'Bearer ' + self.apiKey
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def fetch_markets(self, params={}) -> List[Market]:
        response = self.v1PublicGetMarketMarketInfo(params)
        # response: array of MarketResponse
        result: List[Market] = []
        for i in range(0, len(response)):
            market = response[i]
            id = self.safe_string(market, 'addr')
            rawSymbol = self.safe_string(market, 'symbol')
            symbol = self.normalize_symbol(rawSymbol) if (rawSymbol is not None) else None
            baseId = self.safe_string(market, 'base_addr')
            quoteId = self.safe_string(market, 'quote_addr')
            baseDecimals = self.safe_integer(market, 'base_decimals')
            quoteDecimals = self.safe_integer(market, 'quote_decimals')
            linear = True
            type = 'swap'
            settle = None
            settleId = None
            active = True
            precision = {'amount': baseDecimals, 'price': quoteDecimals}
            result.append({
                'id': id,
                'symbol': symbol,
                'base': baseId,
                'quote': quoteId,
                'baseId': baseId,
                'quoteId': quoteId,
                'type': type,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'contract': True,
                'linear': linear,
                'inverse': not linear,
                'settle': settle,
                'settleId': settleId,
                'active': active,
                'precision': precision,
                'limits': {},
                'info': market,
            })
        return result

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        id = self.safe_string(trade, 'sid')
        side = self.safe_string_lower(trade, 'side')
        ts = self.safe_integer(trade, 'timestamp')
        timestamp = self.parse_to_int(ts) if (ts is not None) else None
        marketId = self.safe_string(trade, 'market_addr')
        market = market or self.safe_market(marketId)
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        sizeInt = self.safe_integer(trade, 'size')
        priceInt = self.safe_integer(trade, 'price')
        amount = None
        price = None
        datetime = self.iso8601(timestamp) if (timestamp is not None) else None
        if baseDecimals is not None and sizeInt is not None:
            amount = sizeInt / math.pow(10, baseDecimals)
        if quoteDecimals is not None and priceInt is not None:
            price = priceInt / math.pow(10, quoteDecimals)
        cost = (amount * price) if (amount is not None and price is not None) else None
        return self.safe_trade({
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': market['symbol'] if market else None,
            'side': side,
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
            'info': trade,
        }, market)

    def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {
            'market_addr': market['id'],
        }
        if limit is not None:
            request['per_page'] = limit
        response = self.v1PublicGetMarketFills(self.extend(request, params))
        # response: array of FillResponse
        trades = self.parse_trades(response, market, since, limit)
        return trades

    def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {'market_addr': market['id']}
        if limit is not None:
            request['per_page'] = limit
        response = self.v1PublicGetMarketOrders(self.extend(request, params))
        # response: array of OrderResponse with side/price/size ints
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        bidsMap: dict = {}
        asksMap: dict = {}
        for i in range(0, len(response)):
            o = response[i]
            side = self.safe_string_lower(o, 'side')
            priceInt = self.safe_integer(o, 'price')
            sizeInt = self.safe_integer(o, 'size')
            if priceInt is None or sizeInt is None:
                continue
            key = str(priceInt)
            sizeFloat = (sizeInt / math.pow(10, baseDecimals)) if (baseDecimals is not None) else None
            if sizeFloat is None:
                continue
            if side == 'buy':
                prev = self.safe_number(bidsMap, key, 0)
                bidsMap[key] = self.sum(prev, sizeFloat)
            elif side == 'sell':
                prev = self.safe_number(asksMap, key, 0)
                asksMap[key] = self.sum(prev, sizeFloat)
        bids = []
        asks = []
        bidKeys = list(bidsMap.keys())
        for i in range(0, len(bidKeys)):
            k = bidKeys[i]
            pInt = self.parse_to_numeric(k)
            pFloat = (pInt / math.pow(10, quoteDecimals)) if (quoteDecimals is not None) else pInt
            bids.append([pFloat, bidsMap[k]])
        askKeys = list(asksMap.keys())
        for i in range(0, len(askKeys)):
            k = askKeys[i]
            pInt = self.parse_to_numeric(k)
            pFloat = (pInt / math.pow(10, quoteDecimals)) if (quoteDecimals is not None) else pInt
            asks.append([pFloat, asksMap[k]])
        orderbook = {'bids': bids, 'asks': asks}
        result = self.parse_order_book(orderbook, symbol)
        if limit is not None:
            result['bids'] = result['bids'][0:limit]
            result['asks'] = result['asks'][0:limit]
        return result

    def fetch_balance(self, params={}) -> Balances:
        # Derive balances from user portfolio endpoint; assumes a single quote asset vault(e.g., USDC)
        self.check_required_credentials()
        response = self.request('user/portfolio', ['v1', 'private'], 'GET', params)
        # response: PortfolioResponse {vault_balances: [{asset_addr, balance}], summary: {total_margin_used}}
        vaults = self.safe_value(response, 'vault_balances', [])
        summary = self.safe_value(response, 'summary', {})
        # Try to detect decimals from markets using the first vault asset
        self.load_markets()
        decimals = None
        code: str = 'USDC'
        if len(vaults) > 0:
            assetAddr = self.safe_string(vaults[0], 'asset_addr')
            # find any market where quoteId == assetAddr
            marketIds = list(self.markets_by_id or {}.keys())
            for i in range(0, len(marketIds)):
                m: Any = self.markets_by_id[marketIds[i]]
                # markets_by_id can map an id to an array of market dicts; use the first
                if isinstance(m, list) and len(m) > 0:
                    m = m[0]
                info = (m['info'] or {}) if m else {}
                quoteId = self.safe_string(info, 'quote_addr')
                if quoteId == assetAddr:
                    decimals = self.safe_integer(info, 'quote_decimals')
                    # Best-effort code detection: try to parse from symbol suffix(e.g., BTC/USDC)
                    sym = self.safe_string(m, 'symbol')
                    if sym:
                        parts = sym.split('/')
                        if len(parts) > 1:
                            code = parts[1].split(':')[0]
                    break
        totalRaw = self.safe_integer(vaults[0] or {}, 'balance')
        usedRaw = self.safe_integer(summary, 'total_margin_used')
        total = None
        if totalRaw is not None:
            total = (totalRaw / math.pow(10, decimals)) if (decimals is not None) else totalRaw
        used = 0
        if usedRaw is not None:
            used = (usedRaw / math.pow(10, decimals)) if (decimals is not None) else usedRaw
        free = (total - used) if (total is not None and used is not None) else None
        result: dict = {'info': response}
        result[code] = {
            'free': free,
            'used': used,
            'total': total,
        }
        return self.safe_balance(result)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        ts = self.safe_integer(ohlcv, 'timestamp')
        timestamp = (ts * 1000) if (ts is not None) else None
        open = self.safe_number(ohlcv, 'open')
        high = self.safe_number(ohlcv, 'high')
        low = self.safe_number(ohlcv, 'low')
        close = self.safe_number(ohlcv, 'close')
        volume = self.safe_number(ohlcv, 'volume')
        return [timestamp, open, high, low, close, volume]

    def fetch_ohlcv(self, symbol: str, timeframe='1h', since: Int = None, limit: Int = None, params={}) -> List[list]:
        self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {
            'market_addr': market['id'],
            'timeframe': timeframe,
        }
        if since is not None:
            request['start_time'] = self.parse_to_int(since / 1000)
        if limit is not None:
            request['per_page'] = limit
        response = self.v1PublicGetMarketCandles(self.extend(request, params))
        # response is array of {timestamp, open, high, low, close, volume, count}
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        self.load_markets()
        market = self.market(self.normalize_symbol(symbol))
        response = self.v1PublicGetMarketCandlesStatsMarketAddr(self.extend({'market_addr': market['id']}, params))
        # MarketStatsResponse: current_price, price_24h_ago, price_change_24h, high_24h, low_24h, volume_24h(quote volume), trades_24h
        last = self.safe_number(response, 'current_price')
        high = self.safe_number(response, 'high_24h')
        low = self.safe_number(response, 'low_24h')
        percentage = self.safe_number(response, 'price_change_24h')
        rawQuoteVolume = self.safe_number(response, 'volume_24h')
        quoteVolume = 0 if (not rawQuoteVolume) else rawQuoteVolume
        baseVolume = 0
        if (quoteVolume > 0) and (last is not None) and (last > 0):
            baseVolume = quoteVolume / last
        return self.safe_ticker({
            'symbol': market['symbol'],
            'timestamp': None,
            'datetime': None,
            'high': high,
            'low': low,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': self.safe_number(response, 'price_24h_ago'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': percentage,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': response,
        }, market)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        id = self.safe_string(order, 'sid')
        statusRaw = self.safe_string(order, 'status')
        side = self.safe_string_lower(order, 'side')
        type = self.safe_string_lower(order, 'type')
        ts = self.safe_integer(order, 'timestamp')
        timestamp = self.parse_to_int(ts) if (ts is not None) else None
        marketId = self.safe_string(order, 'market_addr')
        market = market or self.safe_market(marketId)
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        size = self.safe_number(order, 'size')
        priceInt = self.safe_integer(order, 'price')
        amount = size
        price = None
        if baseDecimals is not None and size is not None:
            amount = size / math.pow(10, baseDecimals)
        if quoteDecimals is not None and priceInt is not None:
            price = priceInt / math.pow(10, quoteDecimals)
        status = None
        # map to ccxt statuses
        if statusRaw == 'placed' or statusRaw == 'created' or statusRaw == 'partial_filled':
            status = 'open'
        elif statusRaw == 'filled':
            status = 'closed'
        elif statusRaw == 'cancelled' or statusRaw == 'rejected':
            status = 'canceled'
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': market['symbol'] if market else None,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'cost': None,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'fee': None,
            'trades': None,
            'info': order,
        }, market)

    def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        request: dict = {}
        if market:
            request['market_addr'] = market['id']
        if limit is not None:
            request['per_page'] = limit
        response = self.v1PrivateGetUserOrders(self.extend(request, params))
        parsed = self.parse_orders(response, market)
        return self.filter_by_array(parsed, 'status', ['open'], False)

    def fetch_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        request: dict = {}
        if market:
            request['market_addr'] = market['id']
        if limit is not None:
            request['per_page'] = limit
        response = self.v1PrivateGetUserOrders(self.extend(request, params))
        parsed = self.parse_orders(response, market)
        return self.filter_by_array(parsed, 'status', ['closed', 'canceled'], False)

    def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        self.load_markets()
        self.check_required_credentials(False)
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol to be specified')
        market = self.market(self.normalize_symbol(symbol))
        request: dict = {'market_addr': market['id'], 'per_page': 50}
        response = self.v1PrivateGetUserOrders(self.extend(request, params))
        for i in range(0, len(response)):
            item = response[i]
            if self.safe_string(item, 'sid') == id:
                return self.parse_order(item, market)
        raise OrderNotFound(self.id + ' fetchOrder() could not find order id ' + id)

    def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        # Ekiden requires signed intents over /api/v1/user/intent(Ed25519, Aptos-style BCS payload + nonce + seed)
        self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol))
        hasPayload = self.is_valid_signed_intent_params(params, 'order_create')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = None
            if commitProvided:
                responseProvided = self.v1PrivatePostUserIntentCommit(request)
            else:
                responseProvided = self.v1PrivatePostUserIntent(request)
            return self.safe_order({'id': None, 'symbol': market['symbol'], 'info': responseProvided})
        if not self.secret:
            raise NotSupported(self.id + ' createOrder() requires either params {payload, signature, nonce} or exchange.secret to sign the intent')
        leverage = self.safe_integer(params, 'leverage', 1)
        commitFlag = self.safe_bool(params, 'commit', True)
        order = self.scale_order_fields(market, side, amount, price, type, leverage)
        payload: dict = {'type': 'order_create', 'orders': [order]}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned = None
        if commitFlag:
            responseSigned = self.v1PrivatePostUserIntentCommit(request)
        else:
            responseSigned = self.v1PrivatePostUserIntent(request)
        # If committed, try to resolve the final order from user/orders by seq
        if commitFlag:
            seq = self.safe_integer(responseSigned, 'seq')
            if seq is not None:
                try:
                    list = self.v1PrivateGetUserOrders({'market_addr': market['id'], 'per_page': 50})
                    for i in range(0, len(list)):
                        it = list[i]
                        if self.safe_integer(it, 'seq') == seq:
                            return self.parse_order(it, market)
                except Exception as e:
                    # ignore and fallback below
                    # eslint-disable-next-line no-unused-vars
                    _ = e  # no-op to satisfy transpilers
        return self.parse_create_order_result(responseSigned, payload, market, amount, price, side, type)

    def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        self.load_markets()
        self.check_required_credentials(False)
        market = self.market(self.normalize_symbol(symbol)) if (symbol is not None) else None
        hasPayload = self.is_valid_signed_intent_params(params, 'order_cancel')
        request: dict = {}
        if hasPayload:
            commitProvided = self.safe_bool(params, 'commit', False)
            request = self.omit(params, ['commit'])
            responseProvided = None
            if commitProvided:
                responseProvided = self.v1PrivatePostUserIntentCommit(request)
            else:
                responseProvided = self.v1PrivatePostUserIntent(request)
            return self.parse_cancel_order_result(responseProvided, id, market)
        if not self.secret:
            raise NotSupported(self.id + ' cancelOrder() requires either params {payload, signature, nonce} or exchange.secret to sign the intent')
        commitFlag = self.safe_bool(params, 'commit', True)
        # Build cancel payload for a single sid(id)
        payload: dict = {'type': 'order_cancel', 'cancels': [{'sid': id}]}
        nonce = self.safe_integer(params, 'nonce') if ('nonce' in params) else self.milliseconds()
        request = self.build_signed_intent(payload, nonce)
        responseSigned2 = None
        if commitFlag:
            responseSigned2 = self.v1PrivatePostUserIntentCommit(request)
        else:
            responseSigned2 = self.v1PrivatePostUserIntent(request)
        return self.parse_cancel_order_result(responseSigned2, id, market)
