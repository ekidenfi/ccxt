# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCacheBySymbolById, ArrayCacheByTimestamp
import math
from ccxt.base.types import Any, Int, Order, Str
from ccxt.async_support.base.ws.client import Client
from typing import List


class ekiden(ccxt.async_support.ekiden):

    def describe(self) -> Any:
        return self.deep_extend(super(ekiden, self).describe(), {
            'has': {
                'ws': True,
                'watchOHLCV': True,
                'watchOrders': True,
            },
            'urls': {
                'api': {
                    'ws': {
                        'public': 'wss://api.ekiden.fi/ws',
                    },
                },
                'test': {
                    'ws': {
                        'public': 'wss://api.staging.ekiden.fi/ws',
                    },
                },
            },
            'streaming': {
                'keepAlive': 20000,
            },
            'options': {
                'OHLCVLimit': 1000,
                'ordersLimit': 1000,
                'ordersPollInterval': 2000,
            },
        })

    async def watch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        # subscribe to public trades channel and aggregate candles client-side
        channel = 'trades/' + market['id']
        url = self.urls['api']['ws']['public']
        request: dict = {
            'method': 'subscribe',
            'channel': channel,
        }
        # ensure cache exists for self symbol/timeframe
        if not (symbol in self.ohlcvs):
            self.ohlcvs[symbol] = {}
        if not (timeframe in self.ohlcvs[symbol]):
            ohlcvLimit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
            self.ohlcvs[symbol][timeframe] = ArrayCacheByTimestamp(ohlcvLimit)
        messageHash = 'candles:' + timeframe + ':' + symbol
        ohlcv = await self.watch(url, messageHash, self.extend(request, params), messageHash)
        if self.newUpdates:
            limit = ohlcv.getLimit(symbol, limit)
        return self.filter_by_since_limit(ohlcv, since, limit, 0, True)

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        # HTTP polling-based watcher since Ekiden WS has no orders channel yet
        await self.load_markets()
        self.check_required_credentials(False)
        market = None
        messageHash = 'order'
        if symbol is not None:
            market = self.market(symbol)
            symbol = market['symbol']
            messageHash = messageHash + ':' + symbol
        url = self.urls['api']['ws']['public']
        client = self.client(url)
        if self.safe_value(client.subscriptions, messageHash) is None:
            client.subscriptions[messageHash] = True
            self.spawn(self.watch_orders_loop, client, messageHash, market, params)
        future = client.future(messageHash)
        orders = await future
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    async def watch_orders_loop(self, client: Client, messageHash: str, market: Any = None, params={}):
        pollMs = self.safe_integer(self.options, 'ordersPollInterval', 2000)
        try:
            request: dict = {}
            if market is not None:
                request['market_addr'] = market['id']
            # fetch the latest user orders(both open/closed)
            response = await self.v1PrivateGetUserOrders(self.extend(request, params))
            if self.orders is None:
                limit = self.safe_integer(self.options, 'ordersLimit', 1000)
                self.orders = ArrayCacheBySymbolById(limit)
            stored = self.orders
            orders = self.parse_orders(response, market)
            symbols: dict = {}
            for i in range(0, len(orders)):
                order = orders[i]
                stored.append(order)
                sym = self.safe_string(order, 'symbol')
                if sym is not None:
                    symbols[sym] = True
            # resolve both generic and per-symbol streams
            client.resolve(stored, 'order')
            keys = list(symbols.keys())
            for i in range(0, len(keys)):
                sym = keys[i]
                innerHash = 'order' + ':' + sym
                client.resolve(stored, innerHash)
        except Exception as e:
            # eslint-disable-next-line no-unused-vars
            _ = e  # no-op to satisfy transpilers
        self.delay(pollMs, self.watch_orders_loop, client, messageHash, market, params)

    def handle_message(self, client: Client, message):
        # Ekiden WS message format(server-side):
        # {type: 'event' | 'subscribed' | 'unsubscribed' | 'pong' | 'error', channel?: string, data?: {type: 'trades' | 'orderbook_snapshot' | 'orderbook_delta', ...}}
        topType = self.safe_string(message, 'type')
        if topType == 'event':
            channel = self.safe_string(message, 'channel')
            data = self.safe_dict(message, 'data', {})
            eventType = self.safe_string(data, 'type')
            if (channel is not None) and (channel.find('trades/') == 0) and (eventType == 'trades'):
                self.handle_trades_for_ohlcv(client, message)
            # ignore orderbook events here(no watchOrderBook implemented yet)
        if topType == 'error':
            err = self.id + ' ' + self.json(message)
            client.reject(err)
        # subscribed / unsubscribed / pong can be ignored

    def handle_trades_for_ohlcv(self, client: Client, message):
        data = self.safe_dict(message, 'data', {})
        marketAddr = self.safe_string(data, 'market_addr')
        market = self.safe_market(marketAddr)
        symbol = market['symbol']
        baseDecimals = self.safe_integer(market['info'] or {}, 'base_decimals')
        quoteDecimals = self.safe_integer(market['info'] or {}, 'quote_decimals')
        trades = self.safe_list(data, 'trades', [])
        if not (symbol in self.ohlcvs):
            # nothing to deliver if there are no OHLCV subscriptions for self symbol
            return
        timeframes = list(self.ohlcvs[symbol].keys())
        if len(timeframes) == 0:
            return
        for i in range(0, len(trades)):
            tr = self.safe_dict(trades, i)
            ts = self.safe_integer(tr, 'timestamp')
            timestamp = (ts * 1000) if (ts is not None) else None
            priceInt = self.safe_integer(tr, 'price')
            sizeInt = self.safe_integer(tr, 'size')
            price = (priceInt / math.pow(10, quoteDecimals)) if (quoteDecimals is not None and priceInt is not None) else None
            amount = (sizeInt / math.pow(10, baseDecimals)) if (baseDecimals is not None and sizeInt is not None) else None
            if (timestamp is None) or (price is None) or (amount is None):
                continue
            for j in range(0, len(timeframes)):
                timeframe = timeframes[j]
                self.append_ohlcv_from_trade(symbol, timeframe, timestamp, price, amount)
        for j in range(0, len(timeframes)):
            timeframe = timeframes[j]
            messageHash = 'candles:' + timeframe + ':' + symbol
            cache = self.ohlcvs[symbol][timeframe]
            client.resolve(cache, messageHash)

    def append_ohlcv_from_trade(self, symbol: str, timeframe: str, timestamp: float, price: float, amount: float):
        if not (symbol in self.ohlcvs):
            self.ohlcvs[symbol] = {}
        stored = self.safe_value(self.ohlcvs[symbol], timeframe)
        if stored is None:
            limit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
            stored = ArrayCacheByTimestamp(limit)
            self.ohlcvs[symbol][timeframe] = stored
        duration = self.parse_timeframe(timeframe) * 1000
        start = self.parse_to_int(int(math.floor(timestamp / duration)) * duration)
        existing = stored.hashmap[start]
        if existing is not None:
            open = existing[1]
            high = max(existing[2], price)
            low = min(existing[3], price)
            close = price
            volume = self.sum(existing[5], amount)
            stored.append([start, open, high, low, close, volume])
        else:
            stored.append([start, price, price, price, price, amount])
